diff --git a/auto/modules b/auto/modules
index 1a5e421..e96f428 100644
--- a/auto/modules
+++ b/auto/modules
@@ -1528,3 +1528,5 @@ cat << END                                    >> $NGX_MODULES_C
 };
 
 END
+
+have=NGX_HTTP_EXT . auto/have
\ No newline at end of file
diff --git a/src/event/ngx_event_connect.c b/src/event/ngx_event_connect.c
index 9b406b2..7b5c956 100644
--- a/src/event/ngx_event_connect.c
+++ b/src/event/ngx_event_connect.c
@@ -80,6 +80,18 @@ ngx_event_connect_peer(ngx_peer_connection_t *pc)
         }
     }
 
+#if (NGX_HTTP_EXT)
+    if (pc->sndbuf) {
+        if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
+                       (const void *) &pc->sndbuf, sizeof(int)) == -1)
+        {
+            ngx_log_error(NGX_LOG_ALERT, pc->log, ngx_socket_errno,
+                          "setsockopt(SO_SNDBUF) failed");
+            goto failed;
+        }
+    }
+#endif
+
     if (pc->so_keepalive) {
         value = 1;
 
diff --git a/src/event/ngx_event_connect.h b/src/event/ngx_event_connect.h
index d3b2378..ad02fc5 100644
--- a/src/event/ngx_event_connect.h
+++ b/src/event/ngx_event_connect.h
@@ -58,6 +58,10 @@ struct ngx_peer_connection_s {
     int                              type;
     int                              rcvbuf;
 
+#if (NGX_HTTP_EXT)
+    int                              sndbuf;
+#endif
+
     ngx_log_t                       *log;
 
     unsigned                         cached:1;
diff --git a/src/event/ngx_event_openssl.c b/src/event/ngx_event_openssl.c
index 9e8f424..776e0b2 100644
--- a/src/event/ngx_event_openssl.c
+++ b/src/event/ngx_event_openssl.c
@@ -1713,6 +1713,9 @@ ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c, ngx_uint_t flags)
     sc->buffer = ((flags & NGX_SSL_BUFFER) != 0);
     sc->buffer_size = ssl->buffer_size;
 
+#if (NGX_HTTP_EXT)
+    sc->dyn_rec = ssl->dyn_rec;
+#endif
     sc->session_ctx = ssl->ctx;
 
 #ifdef SSL_READ_EARLY_DATA_SUCCESS
@@ -1801,6 +1804,10 @@ ngx_ssl_handshake(ngx_connection_t *c)
     ngx_err_t  err;
     ngx_int_t  rc;
 
+#if (NGX_HTTP_EXT)
+    ngx_time_t *tp;
+#endif
+
 #ifdef SSL_READ_EARLY_DATA_SUCCESS
     if (c->ssl->try_early_data) {
         return ngx_ssl_try_early_data(c);
@@ -1875,6 +1882,11 @@ ngx_ssl_handshake(ngx_connection_t *c)
 
         c->ssl->handshaked = 1;
 
+#if (NGX_HTTP_EXT)
+        tp = ngx_timeofday();
+        c->ssl->handshake_end_msec = tp->sec * 1000 + tp->msec;
+#endif
+
         return NGX_OK;
     }
 
@@ -2757,6 +2769,43 @@ ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
 
     for ( ;; ) {
 
+#if (NGX_HTTP_EXT)
+        /* Dynamic record resizing:
+           We want the initial records to fit into one TCP segment
+           so we don't get TCP HoL blocking due to TCP Slow Start.
+           A connection always starts with small records, but after
+           a given amount of records sent, we make the records larger
+           to reduce header overhead.
+           After a connection has idled for a given timeout, begin
+           the process from the start. The actual parameters are
+           configurable. If dyn_rec_timeout is 0, we assume dyn_rec is off. */
+
+        if (c->ssl->dyn_rec.timeout > 0 ) {
+
+            if (ngx_current_msec - c->ssl->dyn_rec_last_write >
+                c->ssl->dyn_rec.timeout)
+            {
+                buf->end = buf->start + c->ssl->dyn_rec.size_lo;
+                c->ssl->dyn_rec_records_sent = 0;
+
+            } else {
+                if (c->ssl->dyn_rec_records_sent >
+                    c->ssl->dyn_rec.threshold * 2)
+                {
+                    buf->end = buf->start + c->ssl->buffer_size;
+
+                } else if (c->ssl->dyn_rec_records_sent >
+                           c->ssl->dyn_rec.threshold)
+                {
+                    buf->end = buf->start + c->ssl->dyn_rec.size_hi;
+
+                } else {
+                    buf->end = buf->start + c->ssl->dyn_rec.size_lo;
+                }
+            }
+        }
+#endif
+
         while (in && buf->last < buf->end && send < limit) {
             if (in->buf->last_buf || in->buf->flush) {
                 flush = 1;
@@ -2896,6 +2945,11 @@ ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)
 
     if (n > 0) {
 
+#if (NGX_HTTP_EXT)
+        c->ssl->dyn_rec_records_sent++;
+        c->ssl->dyn_rec_last_write = ngx_current_msec;
+#endif
+
         if (c->ssl->saved_read_handler) {
 
             c->read->handler = c->ssl->saved_read_handler;
@@ -6021,6 +6075,93 @@ ngx_ssl_get_client_v_remain(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
 }
 
 
+#if (NGX_HTTP_EXT)
+ngx_int_t
+ngx_ssl_get_handshake_time(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    ngx_msec_int_t   ms;
+    u_char          *p;
+    ngx_time_t      *tp;
+
+    if (c->ssl == NULL) {
+        ngx_str_null(s);
+
+        return NGX_OK;
+    }
+
+    tp = ngx_timeofday();
+
+    if (c->ssl->handshake_end_msec == 0) {
+        ms = tp->sec * 1000 + tp->msec - c->ssl->handshake_start_msec;
+    } else {
+        ms = c->ssl->handshake_end_msec - c->ssl->handshake_start_msec;
+    }
+
+    ms = ngx_max(ms, 0);
+
+    p = ngx_pnalloc(pool, NGX_TIME_T_LEN + 4);
+    if (p == NULL) {
+        return NGX_ERROR;
+    }
+
+    s->len = ngx_sprintf(p, "%T.%03M", (time_t) ms / 1000, ms % 1000) - p;
+    s->data = p;
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_get_handshake_start_ts(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s) {
+    ngx_msec_t       ms;
+    u_char          *p;
+
+    if (c->ssl == NULL || c->ssl->handshake_start_msec == 0) {
+        ngx_str_null(s);
+
+        return NGX_OK;
+    }
+
+    ms = c->ssl->handshake_start_msec;
+
+    p = ngx_pnalloc(pool, NGX_TIME_T_LEN + 4);
+    if (p == NULL) {
+        return NGX_ERROR;
+    }
+
+    s->len = ngx_sprintf(p, "%T.%03M", (time_t) ms / 1000, ms % 1000) - p;
+    s->data = p;
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_get_handshake_end_ts(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s) {
+    ngx_msec_t       ms;
+    u_char          *p;
+
+    if (c->ssl == NULL || c->ssl->handshake_end_msec == 0) {
+        ngx_str_null(s);
+
+        return NGX_OK;
+    }
+
+    ms = c->ssl->handshake_end_msec;
+
+    p = ngx_pnalloc(pool, NGX_TIME_T_LEN + 4);
+    if (p == NULL) {
+        return NGX_ERROR;
+    }
+
+    s->len = ngx_sprintf(p, "%T.%03M", (time_t) ms / 1000, ms % 1000) - p;
+    s->data = p;
+
+    return NGX_OK;
+}
+#endif
+
+
 static time_t
 ngx_ssl_parse_time(
 #if OPENSSL_VERSION_NUMBER > 0x10100000L
diff --git a/src/event/ngx_event_openssl.h b/src/event/ngx_event_openssl.h
index ebb2c35..427306e 100644
--- a/src/event/ngx_event_openssl.h
+++ b/src/event/ngx_event_openssl.h
@@ -86,10 +86,23 @@
 typedef struct ngx_ssl_ocsp_s  ngx_ssl_ocsp_t;
 
 
+#if (NGX_HTTP_EXT)
+typedef struct {
+    ngx_msec_t                  timeout;
+    ngx_uint_t                  threshold;
+    size_t                      size_lo;
+    size_t                      size_hi;
+} ngx_ssl_dyn_rec_t;
+#endif
+
+
 struct ngx_ssl_s {
     SSL_CTX                    *ctx;
     ngx_log_t                  *log;
     size_t                      buffer_size;
+#if (NGX_HTTP_EXT)
+    ngx_ssl_dyn_rec_t           dyn_rec;
+#endif
 };
 
 
@@ -109,6 +122,11 @@ struct ngx_ssl_connection_s {
     ngx_event_handler_pt        saved_read_handler;
     ngx_event_handler_pt        saved_write_handler;
 
+#if (NGX_HTTP_EXT)
+    ngx_msec_t                  handshake_start_msec;
+    ngx_msec_t                  handshake_end_msec;
+#endif
+
     ngx_ssl_ocsp_t             *ocsp;
 
     u_char                      early_buf;
@@ -128,6 +146,11 @@ struct ngx_ssl_connection_s {
     unsigned                    in_ocsp:1;
     unsigned                    early_preread:1;
     unsigned                    write_blocked:1;
+#if (NGX_HTTP_EXT)
+    ngx_ssl_dyn_rec_t           dyn_rec;
+    ngx_msec_t                  dyn_rec_last_write;
+    ngx_uint_t                  dyn_rec_records_sent;
+#endif
 };
 
 
@@ -137,7 +160,11 @@ struct ngx_ssl_connection_s {
 #define NGX_SSL_DFLT_BUILTIN_SCACHE  -5
 
 
+#if (NGX_HTTP_EXT)
+#define NGX_SSL_MAX_SESSION_SIZE  16384
+#else
 #define NGX_SSL_MAX_SESSION_SIZE  4096
+#endif
 
 typedef struct ngx_ssl_sess_id_s  ngx_ssl_sess_id_t;
 
@@ -307,6 +334,14 @@ ngx_int_t ngx_ssl_get_client_v_end(ngx_connection_t *c, ngx_pool_t *pool,
     ngx_str_t *s);
 ngx_int_t ngx_ssl_get_client_v_remain(ngx_connection_t *c, ngx_pool_t *pool,
     ngx_str_t *s);
+#if (NGX_HTTP_EXT)
+ngx_int_t ngx_ssl_get_handshake_time(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_handshake_start_ts(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_handshake_end_ts(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+#endif
 
 
 ngx_int_t ngx_ssl_handshake(ngx_connection_t *c);
diff --git a/src/http/modules/ngx_http_auth_basic_module.c b/src/http/modules/ngx_http_auth_basic_module.c
index 02d41e8..e80ce78 100644
--- a/src/http/modules/ngx_http_auth_basic_module.c
+++ b/src/http/modules/ngx_http_auth_basic_module.c
@@ -14,9 +14,21 @@
 #define NGX_HTTP_AUTH_BUF_SIZE  2048
 
 
+#if (NGX_HTTP_EXT)
+typedef struct {
+    ngx_str_t                  user;
+} ngx_http_auth_basic_user_t;
+#endif
+
+
 typedef struct {
     ngx_http_complex_value_t  *realm;
     ngx_http_complex_value_t  *user_file;
+
+#if (NGX_HTTP_EXT)
+    ngx_array_t               *users;
+#endif
+
 } ngx_http_auth_basic_loc_conf_t;
 
 
@@ -31,6 +43,10 @@ static char *ngx_http_auth_basic_merge_loc_conf(ngx_conf_t *cf,
 static ngx_int_t ngx_http_auth_basic_init(ngx_conf_t *cf);
 static char *ngx_http_auth_basic_user_file(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
+#if (NGX_HTTP_EXT)
+static char *ngx_http_auth_basic_add_user(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+#endif
 
 
 static ngx_command_t  ngx_http_auth_basic_commands[] = {
@@ -51,6 +67,16 @@ static ngx_command_t  ngx_http_auth_basic_commands[] = {
       offsetof(ngx_http_auth_basic_loc_conf_t, user_file),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("auth_basic_user"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LMT_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_http_auth_basic_add_user,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_auth_basic_loc_conf_t, users),
+      NULL },
+#endif
+
       ngx_null_command
 };
 
@@ -98,6 +124,11 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)
     ngx_uint_t                       i, level, login, left, passwd;
     ngx_file_t                       file;
     ngx_http_auth_basic_loc_conf_t  *alcf;
+#if (NGX_HTTP_EXT)
+    ngx_http_auth_basic_user_t      *u;
+    u_char                          *colon;
+    size_t                           login_len;
+#endif
     u_char                           buf[NGX_HTTP_AUTH_BUF_SIZE];
     enum {
         sw_login,
@@ -107,9 +138,20 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)
 
     alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_basic_module);
 
+#if (NGX_HTTP_EXT)
+    if (alcf->realm == NULL) {
+        return NGX_DECLINED;
+    }
+
+    if (alcf->user_file == NULL
+        && (alcf->users == NULL || alcf->users->nelts == 0)) {
+        return NGX_DECLINED;
+    }
+#else
     if (alcf->realm == NULL || alcf->user_file == NULL) {
         return NGX_DECLINED;
     }
+#endif
 
     if (ngx_http_complex_value(r, alcf->realm, &realm) != NGX_OK) {
         return NGX_ERROR;
@@ -133,6 +175,47 @@ ngx_http_auth_basic_handler(ngx_http_request_t *r)
         return NGX_HTTP_INTERNAL_SERVER_ERROR;
     }
 
+#if (NGX_HTTP_EXT)
+    if (alcf->users && alcf->users->nelts > 0) {
+        u = alcf->users->elts;
+
+        for (i = 0; i < alcf->users->nelts; i++) {
+
+            colon = (u_char *) ngx_strlchr(u[i].user.data,
+                        u[i].user.data + u[i].user.len, ':');
+            if (colon == NULL) {
+                continue;
+            }
+
+            login_len = (size_t) (colon - u[i].user.data);
+
+            if (r->headers_in.user.len != login_len) {
+                continue;
+            }
+
+            if (ngx_strncmp(r->headers_in.user.data, u[i].user.data,
+                login_len) != 0)
+            {
+                continue;
+            }
+
+            pwd.data = colon + 1;
+            pwd.len  = u[i].user.len - (pwd.data - u[i].user.data);
+
+            rc = ngx_http_auth_basic_crypt_handler(r, &pwd, &realm);
+
+            return rc;
+        }
+
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                      "user \"%V\" was not found in "
+                      "auth_basic_user directives",
+                      &r->headers_in.user);
+
+        return ngx_http_auth_basic_set_realm(r, &realm);
+    }
+#endif
+
     if (ngx_http_complex_value(r, alcf->user_file, &user_file) != NGX_OK) {
         return NGX_ERROR;
     }
@@ -360,6 +443,9 @@ ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf)
 
     conf->realm = NGX_CONF_UNSET_PTR;
     conf->user_file = NGX_CONF_UNSET_PTR;
+#if (NGX_HTTP_EXT)
+    conf->users = NGX_CONF_UNSET_PTR;
+#endif
 
     return conf;
 }
@@ -372,7 +458,24 @@ ngx_http_auth_basic_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_http_auth_basic_loc_conf_t  *conf = child;
 
     ngx_conf_merge_ptr_value(conf->realm, prev->realm, NULL);
+#if !(NGX_HTTP_EXT)
     ngx_conf_merge_ptr_value(conf->user_file, prev->user_file, NULL);
+#endif
+
+#if (NGX_HTTP_EXT)
+    if (conf->users == NGX_CONF_UNSET_PTR
+        && conf->user_file == NGX_CONF_UNSET_PTR)
+    {
+        ngx_conf_merge_ptr_value(conf->user_file, prev->user_file, NULL);
+        conf->users = (prev->users == NGX_CONF_UNSET_PTR) ? NULL : prev->users;
+
+    } else if (conf->users == NGX_CONF_UNSET_PTR) {
+        conf->users = NULL;
+
+    } else if (conf->user_file == NGX_CONF_UNSET_PTR) {
+        conf->user_file = NULL;
+    }
+#endif
 
     return NGX_CONF_OK;
 }
@@ -409,6 +512,12 @@ ngx_http_auth_basic_user_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
         return "is duplicate";
     }
 
+#if (NGX_HTTP_EXT)
+    if (alcf->users != NGX_CONF_UNSET_PTR) {
+        return "is incompatible with \"auth_basic_user\"";
+    }
+#endif
+
     alcf->user_file = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t));
     if (alcf->user_file == NULL) {
         return NGX_CONF_ERROR;
@@ -430,3 +539,74 @@ ngx_http_auth_basic_user_file(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 
     return NGX_CONF_OK;
 }
+
+
+#if (NGX_HTTP_EXT)
+static char *
+ngx_http_auth_basic_add_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_http_auth_basic_loc_conf_t *alcf = conf;
+
+    ngx_str_t                      *value;
+    ngx_http_auth_basic_user_t     *user;
+    ngx_uint_t                      colons;
+    ngx_uint_t                      i;
+    ngx_uint_t                      len;
+
+    if (alcf->user_file != NGX_CONF_UNSET_PTR) {
+        return "is incompatible with \"auth_basic_user_file\"";
+    }
+
+    if (alcf->users == NGX_CONF_UNSET_PTR || alcf->users == NULL) {
+        alcf->users = ngx_array_create(cf->pool, 1,
+            sizeof(ngx_http_auth_basic_user_t));
+        if (alcf->users == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    value = cf->args->elts;
+
+    colons = 0;
+    len = value[1].len;
+    for (i = 0; i < value[1].len; i++) {
+        if (value[1].data[i] == ':') {
+            colons++;
+            if (colons == 2) {
+                len = i;
+                break;
+            }
+        }
+    }
+
+    if (colons < 1) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+            "auth_basic_user must contain at least one colon");
+        return NGX_CONF_ERROR;
+    }
+
+    user = ngx_array_push(alcf->users);
+    if (user == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_memzero(user, sizeof(*user));
+
+    if (colons > 1) {
+        user->user.len = len;
+
+        user->user.data = ngx_pnalloc(cf->pool, len + 1);
+        if (user->user.data == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        ngx_memcpy(user->user.data, value[1].data, len);
+        user->user.data[len] = '\0';
+
+    } else {
+        user->user = value[1];
+    }
+
+    return NGX_CONF_OK;
+}
+#endif
diff --git a/src/http/modules/ngx_http_fastcgi_module.c b/src/http/modules/ngx_http_fastcgi_module.c
index 46a56f5..fe1c1e7 100644
--- a/src/http/modules/ngx_http_fastcgi_module.c
+++ b/src/http/modules/ngx_http_fastcgi_module.c
@@ -42,6 +42,11 @@ typedef struct {
 
     ngx_flag_t                     keep_conn;
 
+#if (NGX_HTTP_EXT)
+    size_t                         sndbuf;
+    size_t                         rcvbuf;
+#endif
+
 #if (NGX_HTTP_CACHE)
     ngx_http_complex_value_t       cache_key;
 #endif
@@ -417,6 +422,15 @@ static ngx_command_t  ngx_http_fastcgi_commands[] = {
       offsetof(ngx_http_fastcgi_loc_conf_t, upstream.no_cache),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("fastcgi_cache_types"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_http_types_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_fastcgi_loc_conf_t, upstream.cache_types_keys),
+      &ngx_http_html_default_types[0] },
+#endif
+
     { ngx_string("fastcgi_cache_valid"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
       ngx_http_file_cache_valid_set_slot,
@@ -424,6 +438,15 @@ static ngx_command_t  ngx_http_fastcgi_commands[] = {
       offsetof(ngx_http_fastcgi_loc_conf_t, upstream.cache_valid),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("fastcgi_cache_min_age"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_http_set_complex_value_sec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_fastcgi_loc_conf_t, upstream.cache_min_age),
+      NULL },
+#endif
+
     { ngx_string("fastcgi_cache_min_uses"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_num_slot,
@@ -445,6 +468,23 @@ static ngx_command_t  ngx_http_fastcgi_commands[] = {
       offsetof(ngx_http_fastcgi_loc_conf_t, upstream.cache_use_stale),
       &ngx_http_fastcgi_next_upstream_masks },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("fastcgi_cache_stale_if_error"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_set_complex_value_sec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_fastcgi_loc_conf_t, upstream.cache_stale_if_error),
+      NULL },
+
+    { ngx_string("fastcgi_cache_stale_while_revalidate"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_set_complex_value_sec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_fastcgi_loc_conf_t,
+                upstream.cache_stale_while_revalidate),
+      NULL },
+#endif
+
     { ngx_string("fastcgi_cache_methods"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
       ngx_conf_set_bitmask_slot,
@@ -559,6 +599,15 @@ static ngx_command_t  ngx_http_fastcgi_commands[] = {
       offsetof(ngx_http_fastcgi_loc_conf_t, upstream.ignore_headers),
       &ngx_http_upstream_ignore_headers_masks },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("fastcgi_ignore_cache_control"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_conf_set_bitmask_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_fastcgi_loc_conf_t, upstream.ignore_cache_control),
+      &ngx_http_upstream_ignore_cache_control_masks },
+#endif
+
     { ngx_string("fastcgi_catch_stderr"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_str_array_slot,
@@ -573,6 +622,22 @@ static ngx_command_t  ngx_http_fastcgi_commands[] = {
       offsetof(ngx_http_fastcgi_loc_conf_t, keep_conn),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("fastcgi_sndbuf_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_fastcgi_loc_conf_t, sndbuf),
+      NULL },
+
+    { ngx_string("fastcgi_rcvbuf_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_fastcgi_loc_conf_t, rcvbuf),
+      NULL },
+#endif
+
       ngx_null_command
 };
 
@@ -728,6 +793,16 @@ ngx_http_fastcgi_handler(ngx_http_request_t *r)
     u->finalize_request = ngx_http_fastcgi_finalize_request;
     r->state = 0;
 
+#if (NGX_HTTP_EXT)
+    if (flcf->sndbuf > 0) {
+        u->peer.sndbuf = flcf->sndbuf;
+    }
+
+    if (flcf->rcvbuf > 0) {
+        u->peer.rcvbuf = flcf->rcvbuf;
+    }
+#endif
+
     u->buffering = flcf->upstream.buffering;
 
     u->pipe = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t));
@@ -2868,10 +2943,13 @@ ngx_http_fastcgi_create_loc_conf(ngx_conf_t *cf)
      *
      *     conf->upstream.bufs.num = 0;
      *     conf->upstream.ignore_headers = 0;
+     *     conf->upstream.ignore_cache_control = 0;
      *     conf->upstream.next_upstream = 0;
      *     conf->upstream.cache_zone = NULL;
      *     conf->upstream.cache_use_stale = 0;
      *     conf->upstream.cache_methods = 0;
+     *     conf->upstream.cache_types = { NULL };
+     *     conf->upstream.cache_types_keys = NULL;
      *     conf->upstream.temp_path = NULL;
      *     conf->upstream.hide_headers_hash = { NULL, 0 };
      *     conf->upstream.store_lengths = NULL;
@@ -2909,7 +2987,14 @@ ngx_http_fastcgi_create_loc_conf(ngx_conf_t *cf)
 
 #if (NGX_HTTP_CACHE)
     conf->upstream.cache = NGX_CONF_UNSET;
+#if (NGX_HTTP_EXT)
+    conf->upstream.cache_min_age = NGX_CONF_UNSET_PTR;
+#endif
     conf->upstream.cache_min_uses = NGX_CONF_UNSET_UINT;
+#if (NGX_HTTP_EXT)
+    conf->upstream.cache_stale_if_error = NGX_CONF_UNSET_PTR;
+    conf->upstream.cache_stale_while_revalidate = NGX_CONF_UNSET_PTR;
+#endif
     conf->upstream.cache_max_range_offset = NGX_CONF_UNSET;
     conf->upstream.cache_bypass = NGX_CONF_UNSET_PTR;
     conf->upstream.no_cache = NGX_CONF_UNSET_PTR;
@@ -2935,6 +3020,10 @@ ngx_http_fastcgi_create_loc_conf(ngx_conf_t *cf)
 
     conf->keep_conn = NGX_CONF_UNSET;
 
+#if (NGX_HTTP_EXT)
+    conf->sndbuf = NGX_CONF_UNSET_SIZE;
+    conf->rcvbuf = NGX_CONF_UNSET_SIZE;
+#endif
     ngx_str_set(&conf->upstream.module, "fastcgi");
 
     return conf;
@@ -3018,6 +3107,11 @@ ngx_http_fastcgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_ptr_value(conf->upstream.limit_rate,
                               prev->upstream.limit_rate, NULL);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_size_value(conf->sndbuf, prev->sndbuf, (size_t) 0);
+    ngx_conf_merge_size_value(conf->rcvbuf, prev->rcvbuf, (size_t) 0);
+#endif
+
 
     ngx_conf_merge_bufs_value(conf->upstream.bufs, prev->upstream.bufs,
                               8, ngx_pagesize);
@@ -3115,6 +3209,11 @@ ngx_http_fastcgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
                               prev->upstream.ignore_headers,
                               NGX_CONF_BITMASK_SET);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_bitmask_value(conf->upstream.ignore_cache_control,
+                              prev->upstream.ignore_cache_control,
+                              NGX_CONF_BITMASK_SET);
+#endif
 
     ngx_conf_merge_bitmask_value(conf->upstream.next_upstream,
                               prev->upstream.next_upstream,
@@ -3157,6 +3256,10 @@ ngx_http_fastcgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
         return NGX_CONF_ERROR;
     }
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_ptr_value(conf->upstream.cache_min_age,
+                              prev->upstream.cache_min_age, NULL);
+#endif
     ngx_conf_merge_uint_value(conf->upstream.cache_min_uses,
                               prev->upstream.cache_min_uses, 1);
 
@@ -3178,6 +3281,15 @@ ngx_http_fastcgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
         conf->upstream.cache_use_stale |= NGX_HTTP_UPSTREAM_FT_NOLIVE;
     }
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_ptr_value(conf->upstream.cache_stale_if_error,
+                              prev->upstream.cache_stale_if_error,
+                              NULL);
+    ngx_conf_merge_ptr_value(conf->upstream.cache_stale_while_revalidate,
+                              prev->upstream.cache_stale_while_revalidate,
+                              NULL);
+#endif
+
     if (conf->upstream.cache_methods == 0) {
         conf->upstream.cache_methods = prev->upstream.cache_methods;
     }
@@ -3190,6 +3302,18 @@ ngx_http_fastcgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_ptr_value(conf->upstream.no_cache,
                              prev->upstream.no_cache, NULL);
 
+#if (NGX_HTTP_EXT)
+    if (ngx_http_merge_types(cf, &conf->upstream.cache_types_keys,
+                             &conf->upstream.cache_types,
+                             &prev->upstream.cache_types_keys,
+                             &prev->upstream.cache_types,
+                             ngx_http_html_default_types)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+#endif
+
     ngx_conf_merge_ptr_value(conf->upstream.cache_valid,
                              prev->upstream.cache_valid, NULL);
 
diff --git a/src/http/modules/ngx_http_grpc_module.c b/src/http/modules/ngx_http_grpc_module.c
index e7726f3..41c4b37 100644
--- a/src/http/modules/ngx_http_grpc_module.c
+++ b/src/http/modules/ngx_http_grpc_module.c
@@ -30,6 +30,13 @@ typedef struct {
     ngx_array_t               *grpc_lengths;
     ngx_array_t               *grpc_values;
 
+#if (NGX_HTTP_EXT)
+    size_t                     sndbuf;
+    size_t                     rcvbuf;
+
+    ngx_flag_t                 headers_inherit;
+#endif
+
 #if (NGX_HTTP_SSL)
     ngx_uint_t                 ssl;
     ngx_uint_t                 ssl_protocols;
@@ -337,6 +344,15 @@ static ngx_command_t  ngx_http_grpc_commands[] = {
       offsetof(ngx_http_grpc_loc_conf_t, headers_source),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("grpc_set_header_inherit"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_grpc_loc_conf_t, headers_inherit),
+      NULL },
+#endif
+
     { ngx_string("grpc_pass_header"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_str_array_slot,
@@ -358,6 +374,22 @@ static ngx_command_t  ngx_http_grpc_commands[] = {
       offsetof(ngx_http_grpc_loc_conf_t, upstream.ignore_headers),
       &ngx_http_upstream_ignore_headers_masks },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("grpc_sndbuf_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_grpc_loc_conf_t, sndbuf),
+      NULL },
+
+    { ngx_string("grpc_rcvbuf_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_grpc_loc_conf_t, rcvbuf),
+      NULL },
+#endif
+
 #if (NGX_HTTP_SSL)
 
     { ngx_string("grpc_ssl_session_reuse"),
@@ -598,6 +630,16 @@ ngx_http_grpc_handler(ngx_http_request_t *r)
 
     r->request_body_no_buffering = 1;
 
+#if (NGX_HTTP_EXT)
+    if (glcf->sndbuf > 0) {
+        u->peer.sndbuf = glcf->sndbuf;
+    }
+
+    if (glcf->rcvbuf > 0) {
+        u->peer.rcvbuf = glcf->rcvbuf;
+    }
+#endif
+
     rc = ngx_http_read_client_request_body(r, ngx_http_upstream_init);
 
     if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
@@ -916,6 +958,10 @@ ngx_http_grpc_create_request(ngx_http_request_t *r)
                        "grpc header: \":method: %V\"", &r->method_name);
     }
 
+#if (NGX_HTTP_EXT)
+    u->method_name = r->method_name;
+#endif
+
 #if (NGX_HTTP_SSL)
     if (u->ssl) {
         *b->last++ = ngx_http_v2_indexed(NGX_HTTP_V2_SCHEME_HTTPS_INDEX);
@@ -4378,6 +4424,10 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)
 
     conf->upstream.intercept_errors = NGX_CONF_UNSET;
 
+#if (NGX_HTTP_EXT)
+    conf->headers_inherit = NGX_CONF_UNSET;
+#endif
+
 #if (NGX_HTTP_SSL)
     conf->upstream.ssl_session_reuse = NGX_CONF_UNSET;
     conf->upstream.ssl_name = NGX_CONF_UNSET_PTR;
@@ -4407,6 +4457,11 @@ ngx_http_grpc_create_loc_conf(ngx_conf_t *cf)
 
     conf->headers_source = NGX_CONF_UNSET_PTR;
 
+#if (NGX_HTTP_EXT)
+    conf->sndbuf = NGX_CONF_UNSET_SIZE;
+    conf->rcvbuf = NGX_CONF_UNSET_SIZE;
+#endif
+
     ngx_str_set(&conf->upstream.module, "grpc");
 
     return conf;
@@ -4420,6 +4475,12 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_http_grpc_loc_conf_t *conf = child;
 
     ngx_int_t                  rc;
+
+#if (NGX_HTTP_EXT)
+    ngx_uint_t                 i;
+    ngx_keyval_t              *src, *h;
+#endif
+
     ngx_hash_init_t            hash;
     ngx_http_core_loc_conf_t  *clcf;
 
@@ -4466,6 +4527,14 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_value(conf->upstream.intercept_errors,
                               prev->upstream.intercept_errors, 0);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_size_value(conf->sndbuf, prev->sndbuf, (size_t) 0);
+    ngx_conf_merge_size_value(conf->rcvbuf, prev->rcvbuf, (size_t) 0);
+
+    ngx_conf_merge_value(conf->headers_inherit,
+                              prev->headers_inherit, 0);
+#endif
+
 #if (NGX_HTTP_SSL)
 
     if (ngx_http_grpc_merge_ssl(cf, conf, prev) != NGX_OK) {
@@ -4549,6 +4618,28 @@ ngx_http_grpc_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     if (conf->headers_source == prev->headers_source) {
         conf->headers = prev->headers;
         conf->host_set = prev->host_set;
+
+#if (NGX_HTTP_EXT)
+    } else if (conf->headers_source
+               && prev->headers_source
+               && prev->headers_source != NGX_CONF_UNSET_PTR)
+    {
+        src = prev->headers_source->elts;
+
+        for (i = 0; i < prev->headers_source->nelts; i++) {
+            if (!conf->headers_inherit) {
+                continue;
+            }
+
+            h = ngx_array_push(conf->headers_source);
+            if (h == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *h = src[i];
+        }
+#endif
+
     }
 
     rc = ngx_http_grpc_init_headers(cf, conf, &conf->headers,
@@ -4625,6 +4716,14 @@ ngx_http_grpc_init_headers(ngx_conf_t *cf, ngx_http_grpc_loc_conf_t *conf,
                 conf->host_set = 1;
             }
 
+#if (NGX_HTTP_EXT)
+            if (src[i].key.len == 10
+                && ngx_strncasecmp(src[i].key.data, (u_char *) ":authority", 10) == 0)
+            {
+                conf->host_set = 1;
+            }
+#endif
+
             s = ngx_array_push(&headers_merged);
             if (s == NULL) {
                 return NGX_ERROR;
diff --git a/src/http/modules/ngx_http_gunzip_filter_module.c b/src/http/modules/ngx_http_gunzip_filter_module.c
index 5d170a1..6ae4a4b 100644
--- a/src/http/modules/ngx_http_gunzip_filter_module.c
+++ b/src/http/modules/ngx_http_gunzip_filter_module.c
@@ -15,6 +15,9 @@
 
 typedef struct {
     ngx_flag_t           enable;
+#if (NGX_HTTP_EXT)
+    ngx_array_t         *force;
+#endif
     ngx_bufs_t           bufs;
 } ngx_http_gunzip_conf_t;
 
@@ -71,6 +74,15 @@ static ngx_command_t  ngx_http_gunzip_filter_commands[] = {
       offsetof(ngx_http_gunzip_conf_t, enable),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("gunzip_force"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_http_set_predicate_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_gunzip_conf_t, force),
+      NULL },
+#endif
+
     { ngx_string("gunzip_buffers"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE2,
       ngx_conf_set_bufs_slot,
@@ -138,6 +150,28 @@ ngx_http_gunzip_header_filter(ngx_http_request_t *r)
         return ngx_http_next_header_filter(r);
     }
 
+#if (NGX_HTTP_EXT)
+    switch (ngx_http_test_predicates(r, conf->force)) {
+
+    case NGX_ERROR:
+        return NGX_ERROR;
+
+    case NGX_OK:
+        r->gzip_vary = 1;
+
+        if (!r->gzip_tested) {
+            if (ngx_http_gzip_ok(r) == NGX_OK) {
+                return ngx_http_next_header_filter(r);
+            }
+
+        } else if (r->gzip_ok) {
+            return ngx_http_next_header_filter(r);
+        }
+        break;
+
+    default: /* NGX_DECLINED */
+        break;
+#else
     r->gzip_vary = 1;
 
     if (!r->gzip_tested) {
@@ -147,6 +181,7 @@ ngx_http_gunzip_header_filter(ngx_http_request_t *r)
 
     } else if (r->gzip_ok) {
         return ngx_http_next_header_filter(r);
+#endif
     }
 
     ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_gunzip_ctx_t));
@@ -665,6 +700,10 @@ ngx_http_gunzip_create_conf(ngx_conf_t *cf)
 
     conf->enable = NGX_CONF_UNSET;
 
+#if (NGX_HTTP_EXT)
+    conf->force  = NGX_CONF_UNSET_PTR;
+#endif
+
     return conf;
 }
 
@@ -677,6 +716,10 @@ ngx_http_gunzip_merge_conf(ngx_conf_t *cf, void *parent, void *child)
 
     ngx_conf_merge_value(conf->enable, prev->enable, 0);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_ptr_value(conf->force, prev->force, NULL);
+#endif
+
     ngx_conf_merge_bufs_value(conf->bufs, prev->bufs,
                               (128 * 1024) / ngx_pagesize, ngx_pagesize);
 
diff --git a/src/http/modules/ngx_http_gzip_filter_module.c b/src/http/modules/ngx_http_gzip_filter_module.c
index b555278..c92016d 100644
--- a/src/http/modules/ngx_http_gzip_filter_module.c
+++ b/src/http/modules/ngx_http_gzip_filter_module.c
@@ -26,7 +26,14 @@ typedef struct {
     size_t               memlevel;
     ssize_t              min_length;
 
+#if (NGX_HTTP_EXT)
+    ssize_t              max_length;
+#endif
+
     ngx_array_t         *types_keys;
+#if (NGX_HTTP_EXT)
+    ngx_array_t         *bypass;
+#endif
 } ngx_http_gzip_conf_t;
 
 
@@ -174,6 +181,22 @@ static ngx_command_t  ngx_http_gzip_filter_commands[] = {
       offsetof(ngx_http_gzip_conf_t, min_length),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("gzip_max_length"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_gzip_conf_t, max_length),
+      NULL },
+
+    { ngx_string("gzip_bypass"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_http_set_predicate_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_gzip_conf_t, bypass),
+      NULL },
+#endif
+
       ngx_null_command
 };
 
@@ -233,13 +256,33 @@ ngx_http_gzip_header_filter(ngx_http_request_t *r)
         || (r->headers_out.content_encoding
             && r->headers_out.content_encoding->value.len)
         || (r->headers_out.content_length_n != -1
+#if (NGX_HTTP_EXT)
+            && (r->headers_out.content_length_n < conf->min_length
+                || (conf->max_length > 0
+                    && r->headers_out.content_length_n > conf->max_length)))
+#else
             && r->headers_out.content_length_n < conf->min_length)
+#endif
         || ngx_http_test_content_type(r, &conf->types) == NULL
         || r->header_only)
     {
         return ngx_http_next_header_filter(r);
     }
 
+#if (NGX_HTTP_EXT)
+    switch (ngx_http_test_predicates(r, conf->bypass)) {
+
+    case NGX_ERROR:
+        return NGX_ERROR;
+
+    case NGX_DECLINED:
+        return ngx_http_next_header_filter(r);
+
+    default: /* NGX_OK */
+        break;
+    }
+#endif
+
     r->gzip_vary = 1;
 
 #if (NGX_HTTP_DEGRADATION)
@@ -1086,6 +1129,11 @@ ngx_http_gzip_create_conf(ngx_conf_t *cf)
     conf->memlevel = NGX_CONF_UNSET_SIZE;
     conf->min_length = NGX_CONF_UNSET;
 
+#if (NGX_HTTP_EXT)
+    conf->max_length = NGX_CONF_UNSET;
+    conf->bypass = NGX_CONF_UNSET_PTR;
+#endif
+
     return conf;
 }
 
@@ -1110,6 +1158,11 @@ ngx_http_gzip_merge_conf(ngx_conf_t *cf, void *parent, void *child)
                               MAX_MEM_LEVEL - 1);
     ngx_conf_merge_value(conf->min_length, prev->min_length, 20);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_value(conf->max_length, prev->max_length, 0);
+    ngx_conf_merge_ptr_value(conf->bypass, prev->bypass, NULL);
+#endif
+
     if (ngx_http_merge_types(cf, &conf->types_keys, &conf->types,
                              &prev->types_keys, &prev->types,
                              ngx_http_html_default_types)
diff --git a/src/http/modules/ngx_http_limit_req_module.c b/src/http/modules/ngx_http_limit_req_module.c
index 2b062a3..c2143a3 100644
--- a/src/http/modules/ngx_http_limit_req_module.c
+++ b/src/http/modules/ngx_http_limit_req_module.c
@@ -52,6 +52,11 @@ typedef struct {
     /* integer value, 1 corresponds to 0.001 r/s */
     ngx_uint_t                   burst;
     ngx_uint_t                   delay;
+#if (NGX_HTTP_EXT)
+    /* integer value, 1 corresponds to 0.001 r/s */
+    ngx_uint_t                   rate;
+    ngx_http_complex_value_t     key;
+#endif
 } ngx_http_limit_req_limit_t;
 
 
@@ -71,8 +76,13 @@ static ngx_msec_t ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits,
     ngx_uint_t n, ngx_uint_t *ep, ngx_http_limit_req_limit_t **limit);
 static void ngx_http_limit_req_unlock(ngx_http_limit_req_limit_t *limits,
     ngx_uint_t n);
+#if (NGX_HTTP_EXT)
+static void ngx_http_limit_req_expire(ngx_http_limit_req_limit_t *limit,
+    ngx_uint_t n);
+#else
 static void ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx,
     ngx_uint_t n);
+#endif
 
 static ngx_int_t ngx_http_limit_req_status_variable(ngx_http_request_t *r,
     ngx_http_variable_value_t *v, uintptr_t data);
@@ -111,7 +121,11 @@ static ngx_command_t  ngx_http_limit_req_commands[] = {
       NULL },
 
     { ngx_string("limit_req"),
+#if (NGX_HTTP_EXT)
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+#else
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE123,
+#endif
       ngx_http_limit_req,
       NGX_HTTP_LOC_CONF_OFFSET,
       0,
@@ -202,6 +216,9 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)
     ngx_http_limit_req_ctx_t    *ctx;
     ngx_http_limit_req_conf_t   *lrcf;
     ngx_http_limit_req_limit_t  *limit, *limits;
+#if (NGX_HTTP_EXT)
+    ngx_http_complex_value_t    *cv;
+#endif
 
     if (r->main->limit_req_status) {
         return NGX_DECLINED;
@@ -224,7 +241,17 @@ ngx_http_limit_req_handler(ngx_http_request_t *r)
 
         ctx = limit->shm_zone->data;
 
+#if (NGX_HTTP_EXT)
+        if (limit->key.value.len > 0) {
+            cv = &limit->key;
+        } else {
+            cv = &ctx->key;
+        }
+
+        if (ngx_http_complex_value(r, cv, &key) != NGX_OK) {
+#else
         if (ngx_http_complex_value(r, &ctx->key, &key) != NGX_OK) {
+#endif
             ngx_http_limit_req_unlock(limits, n);
             return NGX_HTTP_INTERNAL_SERVER_ERROR;
         }
@@ -412,6 +439,9 @@ ngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit, ngx_uint_t hash,
     ngx_rbtree_node_t          *node, *sentinel;
     ngx_http_limit_req_ctx_t   *ctx;
     ngx_http_limit_req_node_t  *lr;
+#if (NGX_HTTP_EXT)
+    ngx_int_t                   rate;
+#endif
 
     now = ngx_current_msec;
 
@@ -451,7 +481,17 @@ ngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit, ngx_uint_t hash,
                 ms = 0;
             }
 
+#if (NGX_HTTP_EXT)
+            if (limit->rate > 0) {
+                rate = limit->rate;
+            } else {
+                rate = ctx->rate;
+            }
+
+            excess = lr->excess - rate * ms / 1000 + 1000;
+#else
             excess = lr->excess - ctx->rate * ms / 1000 + 1000;
+#endif
 
             if (excess < 0) {
                 excess = 0;
@@ -489,12 +529,20 @@ ngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit, ngx_uint_t hash,
            + offsetof(ngx_http_limit_req_node_t, data)
            + key->len;
 
+#if (NGX_HTTP_EXT)
+    ngx_http_limit_req_expire(limit, 1);
+#else
     ngx_http_limit_req_expire(ctx, 1);
+#endif
 
     node = ngx_slab_alloc_locked(ctx->shpool, size);
 
     if (node == NULL) {
+#if (NGX_HTTP_EXT)
+        ngx_http_limit_req_expire(limit, 0);
+#else
         ngx_http_limit_req_expire(ctx, 0);
+#endif
 
         node = ngx_slab_alloc_locked(ctx->shpool, size);
         if (node == NULL) {
@@ -541,6 +589,9 @@ ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits, ngx_uint_t n,
     ngx_msec_int_t              ms;
     ngx_http_limit_req_ctx_t   *ctx;
     ngx_http_limit_req_node_t  *lr;
+#if (NGX_HTTP_EXT)
+    ngx_int_t                   rate;
+#endif
 
     excess = *ep;
 
@@ -549,7 +600,16 @@ ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits, ngx_uint_t n,
 
     } else {
         ctx = (*limit)->shm_zone->data;
+#if (NGX_HTTP_EXT)
+        if ((*limit)->rate > 0) {
+            rate = (*limit)->rate;
+        } else {
+            rate = ctx->rate;
+        }
+        max_delay = (excess - (*limit)->delay) * 1000 / rate;
+#else
         max_delay = (excess - (*limit)->delay) * 1000 / ctx->rate;
+#endif
     }
 
     while (n--) {
@@ -572,7 +632,17 @@ ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits, ngx_uint_t n,
             ms = 0;
         }
 
+#if (NGX_HTTP_EXT)
+        if (limits[n].rate > 0) {
+            rate = limits[n].rate;
+        } else {
+            rate = ctx->rate;
+        }
+
+        excess = lr->excess - rate * ms / 1000 + 1000;
+#else
         excess = lr->excess - ctx->rate * ms / 1000 + 1000;
+#endif
 
         if (excess < 0) {
             excess = 0;
@@ -593,7 +663,17 @@ ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits, ngx_uint_t n,
             continue;
         }
 
+#if (NGX_HTTP_EXT)
+        if (limits[n].rate > 0) {
+            rate = limits[n].rate;
+        } else {
+            rate = ctx->rate;
+        }
+
+        delay = (excess - limits[n].delay) * 1000 / rate;
+#else
         delay = (excess - limits[n].delay) * 1000 / ctx->rate;
+#endif
 
         if (delay > max_delay) {
             max_delay = delay;
@@ -629,8 +709,13 @@ ngx_http_limit_req_unlock(ngx_http_limit_req_limit_t *limits, ngx_uint_t n)
 }
 
 
+#if (NGX_HTTP_EXT)
+static void
+ngx_http_limit_req_expire(ngx_http_limit_req_limit_t *limit, ngx_uint_t n)
+#else
 static void
 ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx, ngx_uint_t n)
+#endif
 {
     ngx_int_t                   excess;
     ngx_msec_t                  now;
@@ -638,7 +723,12 @@ ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx, ngx_uint_t n)
     ngx_msec_int_t              ms;
     ngx_rbtree_node_t          *node;
     ngx_http_limit_req_node_t  *lr;
+#if (NGX_HTTP_EXT)
+    ngx_http_limit_req_ctx_t   *ctx;
+    ngx_int_t                   rate;
 
+    ctx = limit->shm_zone->data;
+#endif
     now = ngx_current_msec;
 
     /*
@@ -676,7 +766,17 @@ ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx, ngx_uint_t n)
                 return;
             }
 
+#if (NGX_HTTP_EXT)
+            if (limit->rate > 0) {
+                rate = limit->rate;
+            } else {
+                rate = ctx->rate;
+            }
+
+            excess = lr->excess - rate * ms / 1000;
+#else
             excess = lr->excess - ctx->rate * ms / 1000;
+#endif
 
             if (excess > 0) {
                 return;
@@ -849,10 +949,24 @@ ngx_http_limit_req_zone(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
         return NGX_CONF_ERROR;
     }
 
+#if (NGX_HTTP_EXT)
+    name.len = 0;
+    if (value[1].len >= 4 && ngx_strncmp(value[1].data, "key=", 4) == 0) {
+        name.len = value[1].len - 4;
+        name.data = value[1].data + 4;
+    } else {
+        name = value[1];
+    }
+#endif
+
     ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));
 
     ccv.cf = cf;
+#if (NGX_HTTP_EXT)
+    ccv.value = &name;
+#else
     ccv.value = &value[1];
+#endif
     ccv.complex_value = &ctx->key;
 
     if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
@@ -965,17 +1079,37 @@ ngx_http_limit_req(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 {
     ngx_http_limit_req_conf_t  *lrcf = conf;
 
+#if (NGX_HTTP_EXT)
+    ngx_int_t                         burst, delay;
+    ngx_str_t                        *value, s;
+    ngx_uint_t                        i;
+    ngx_shm_zone_t                   *shm_zone;
+    ngx_http_limit_req_limit_t       *limit, *limits;
+    ngx_int_t                         rate, scale;
+    size_t                            len;
+    u_char                           *p;
+    ngx_str_t                         key;
+    ngx_http_compile_complex_value_t  ccv;
+#else
     ngx_int_t                    burst, delay;
     ngx_str_t                   *value, s;
     ngx_uint_t                   i;
     ngx_shm_zone_t              *shm_zone;
     ngx_http_limit_req_limit_t  *limit, *limits;
+#endif
 
     value = cf->args->elts;
 
     shm_zone = NULL;
     burst = 0;
+#if (NGX_HTTP_EXT)
+    delay = NGX_MAX_INT_T_VALUE / 1000;
+    rate = 0;
+    scale = 1;
+    key.len = 0;
+#else
     delay = 0;
+#endif
 
     for (i = 1; i < cf->args->nelts; i++) {
 
@@ -1008,7 +1142,11 @@ ngx_http_limit_req(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
         if (ngx_strncmp(value[i].data, "delay=", 6) == 0) {
 
             delay = ngx_atoi(value[i].data + 6, value[i].len - 6);
+#if (NGX_HTTP_EXT)
+            if (delay < 0) {
+#else
             if (delay <= 0) {
+#endif
                 ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                                    "invalid delay value \"%V\"", &value[i]);
                 return NGX_CONF_ERROR;
@@ -1022,6 +1160,39 @@ ngx_http_limit_req(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
             continue;
         }
 
+#if (NGX_HTTP_EXT)
+        if (ngx_strncmp(value[i].data, "rate=", 5) == 0) {
+
+            len = value[i].len;
+            p = value[i].data + len - 3;
+
+            if (ngx_strncmp(p, "r/s", 3) == 0) {
+                scale = 1;
+                len -= 3;
+
+            } else if (ngx_strncmp(p, "r/m", 3) == 0) {
+                scale = 60;
+                len -= 3;
+            }
+
+            rate = ngx_atoi(value[i].data + 5, len - 5);
+            if (rate <= 0) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                                   "invalid rate \"%V\"", &value[i]);
+                return NGX_CONF_ERROR;
+            }
+
+            continue;
+        }
+
+        if (ngx_strncmp(value[i].data, "key=", 4) == 0) {
+            key.len = value[i].len - 4;
+            key.data = value[i].data + 4;
+
+            continue;
+        }
+#endif
+
         ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                            "invalid parameter \"%V\"", &value[i]);
         return NGX_CONF_ERROR;
@@ -1045,11 +1216,14 @@ ngx_http_limit_req(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
         }
     }
 
+/* allow multiple rules to use the same shared zone */
+#if !(NGX_HTTP_EXT)
     for (i = 0; i < lrcf->limits.nelts; i++) {
         if (shm_zone == limits[i].shm_zone) {
             return "is duplicate";
         }
     }
+#endif
 
     limit = ngx_array_push(&lrcf->limits);
     if (limit == NULL) {
@@ -1059,6 +1233,19 @@ ngx_http_limit_req(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
     limit->shm_zone = shm_zone;
     limit->burst = burst * 1000;
     limit->delay = delay * 1000;
+#if (NGX_HTTP_EXT)
+    limit->rate = rate * 1000 / scale;
+
+    ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));
+
+    ccv.cf = cf;
+    ccv.value = &key;
+    ccv.complex_value = &limit->key;
+
+    if (ngx_http_compile_complex_value(&ccv) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+#endif
 
     return NGX_CONF_OK;
 }
diff --git a/src/http/modules/ngx_http_log_module.c b/src/http/modules/ngx_http_log_module.c
index 79f494f..ed31e29 100644
--- a/src/http/modules/ngx_http_log_module.c
+++ b/src/http/modules/ngx_http_log_module.c
@@ -69,6 +69,9 @@ typedef struct {
     ngx_syslog_peer_t          *syslog_peer;
     ngx_http_log_fmt_t         *format;
     ngx_http_complex_value_t   *filter;
+#if (NGX_HTTP_EXT)
+    ngx_uint_t                  negative;
+#endif
 } ngx_http_log_t;
 
 
@@ -291,7 +294,17 @@ ngx_http_log_handler(ngx_http_request_t *r)
             }
 
             if (val.len == 0 || (val.len == 1 && val.data[0] == '0')) {
+#if (NGX_HTTP_EXT)
+                if (!log[l].negative) {
+                    continue;
+                }
+            } else {
+                if (log[l].negative) {
+                    continue;
+                }
+#else
                 continue;
+#endif
             }
         }
 
@@ -1455,9 +1468,23 @@ process_formats:
 #endif
         }
 
+#if (NGX_HTTP_EXT)
+        if (ngx_strncmp(value[i].data, "if=", 3) == 0
+            || ngx_strncmp(value[i].data, "if!=", 4) == 0)
+        {
+            if (ngx_strncmp(value[i].data, "if=", 3) == 0) {
+                s.len = value[i].len - 3;
+                s.data = value[i].data + 3;
+            } else {
+                s.len = value[i].len - 4;
+                s.data = value[i].data + 4;
+                log->negative = 1;
+            }
+#else
         if (ngx_strncmp(value[i].data, "if=", 3) == 0) {
             s.len = value[i].len - 3;
             s.data = value[i].data + 3;
+#endif
 
             ngx_memzero(&ccv, sizeof(ngx_http_compile_complex_value_t));
 
diff --git a/src/http/modules/ngx_http_proxy_module.c b/src/http/modules/ngx_http_proxy_module.c
index c69a476..052870b 100644
--- a/src/http/modules/ngx_http_proxy_module.c
+++ b/src/http/modules/ngx_http_proxy_module.c
@@ -112,11 +112,20 @@ typedef struct {
 
     ngx_flag_t                     redirect;
 
+#if (NGX_HTTP_EXT)
+    size_t                         sndbuf;
+    size_t                         rcvbuf;
+#endif
+
     ngx_uint_t                     http_version;
 
     ngx_uint_t                     headers_hash_max_size;
     ngx_uint_t                     headers_hash_bucket_size;
 
+#if (NGX_HTTP_EXT)
+    ngx_flag_t                     headers_inherit;
+#endif
+
 #if (NGX_HTTP_SSL)
     ngx_uint_t                     ssl;
     ngx_uint_t                     ssl_protocols;
@@ -415,6 +424,15 @@ static ngx_command_t  ngx_http_proxy_commands[] = {
       offsetof(ngx_http_proxy_loc_conf_t, headers_source),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("proxy_set_header_inherit"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_proxy_loc_conf_t, headers_inherit),
+      NULL },
+#endif
+
     { ngx_string("proxy_headers_hash_max_size"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_num_slot,
@@ -536,6 +554,15 @@ static ngx_command_t  ngx_http_proxy_commands[] = {
       offsetof(ngx_http_proxy_loc_conf_t, upstream.no_cache),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("proxy_cache_types"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_http_types_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_proxy_loc_conf_t, upstream.cache_types_keys),
+      &ngx_http_html_default_types[0] },
+#endif
+
     { ngx_string("proxy_cache_valid"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
       ngx_http_file_cache_valid_set_slot,
@@ -543,6 +570,15 @@ static ngx_command_t  ngx_http_proxy_commands[] = {
       offsetof(ngx_http_proxy_loc_conf_t, upstream.cache_valid),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("proxy_cache_min_age"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_http_set_complex_value_sec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_proxy_loc_conf_t, upstream.cache_min_age),
+      NULL },
+#endif
+
     { ngx_string("proxy_cache_min_uses"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_num_slot,
@@ -564,6 +600,23 @@ static ngx_command_t  ngx_http_proxy_commands[] = {
       offsetof(ngx_http_proxy_loc_conf_t, upstream.cache_use_stale),
       &ngx_http_proxy_next_upstream_masks },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("proxy_cache_stale_if_error"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_set_complex_value_sec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_proxy_loc_conf_t, upstream.cache_stale_if_error),
+      NULL },
+
+    { ngx_string("proxy_cache_stale_while_revalidate"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_set_complex_value_sec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_proxy_loc_conf_t,
+                upstream.cache_stale_while_revalidate),
+      NULL },
+#endif
+
     { ngx_string("proxy_cache_methods"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
       ngx_conf_set_bitmask_slot,
@@ -678,6 +731,15 @@ static ngx_command_t  ngx_http_proxy_commands[] = {
       offsetof(ngx_http_proxy_loc_conf_t, upstream.ignore_headers),
       &ngx_http_upstream_ignore_headers_masks },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("proxy_ignore_cache_control"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_conf_set_bitmask_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_proxy_loc_conf_t, upstream.ignore_cache_control),
+      &ngx_http_upstream_ignore_cache_control_masks },
+#endif
+
     { ngx_string("proxy_http_version"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_enum_slot,
@@ -685,6 +747,22 @@ static ngx_command_t  ngx_http_proxy_commands[] = {
       offsetof(ngx_http_proxy_loc_conf_t, http_version),
       &ngx_http_proxy_http_version },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("proxy_sndbuf_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_proxy_loc_conf_t, sndbuf),
+      NULL },
+
+    { ngx_string("proxy_rcvbuf_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_proxy_loc_conf_t, rcvbuf),
+      NULL },
+#endif
+
 #if (NGX_HTTP_SSL)
 
     { ngx_string("proxy_ssl_session_reuse"),
@@ -998,6 +1076,16 @@ ngx_http_proxy_handler(ngx_http_request_t *r)
 
     u->buffering = plcf->upstream.buffering;
 
+#if (NGX_HTTP_EXT)
+    if (plcf->sndbuf > 0) {
+        u->peer.sndbuf = plcf->sndbuf;
+    }
+
+    if (plcf->rcvbuf > 0) {
+        u->peer.rcvbuf = plcf->rcvbuf;
+    }
+#endif
+
     u->pipe = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t));
     if (u->pipe == NULL) {
         return NGX_HTTP_INTERNAL_SERVER_ERROR;
@@ -1275,6 +1363,10 @@ ngx_http_proxy_create_request(ngx_http_request_t *r)
         method = r->method_name;
     }
 
+#if (NGX_HTTP_EXT)
+    u->method_name = method;
+#endif
+
     ctx = ngx_http_get_module_ctx(r, ngx_http_proxy_module);
 
     if (method.len == 4
@@ -3325,10 +3417,13 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)
      *
      *     conf->upstream.bufs.num = 0;
      *     conf->upstream.ignore_headers = 0;
+     *     conf->upstream.ignore_cache_control = 0;
      *     conf->upstream.next_upstream = 0;
      *     conf->upstream.cache_zone = NULL;
      *     conf->upstream.cache_use_stale = 0;
      *     conf->upstream.cache_methods = 0;
+     *     conf->upstream.cache_types = { NULL };
+     *     conf->upstream.cache_types_keys = NULL;
      *     conf->upstream.temp_path = NULL;
      *     conf->upstream.hide_headers_hash = { NULL, 0 };
      *     conf->upstream.store_lengths = NULL;
@@ -3382,7 +3477,14 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)
 
 #if (NGX_HTTP_CACHE)
     conf->upstream.cache = NGX_CONF_UNSET;
+#if (NGX_HTTP_EXT)
+    conf->upstream.cache_min_age = NGX_CONF_UNSET_PTR;
+#endif
     conf->upstream.cache_min_uses = NGX_CONF_UNSET_UINT;
+#if (NGX_HTTP_EXT)
+    conf->upstream.cache_stale_if_error = NGX_CONF_UNSET_PTR;
+    conf->upstream.cache_stale_while_revalidate = NGX_CONF_UNSET_PTR;
+#endif
     conf->upstream.cache_max_range_offset = NGX_CONF_UNSET;
     conf->upstream.cache_bypass = NGX_CONF_UNSET_PTR;
     conf->upstream.no_cache = NGX_CONF_UNSET_PTR;
@@ -3400,6 +3502,10 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)
 
     conf->upstream.intercept_errors = NGX_CONF_UNSET;
 
+#if (NGX_HTTP_EXT)
+    conf->headers_inherit = NGX_CONF_UNSET;
+#endif
+
 #if (NGX_HTTP_SSL)
     conf->upstream.ssl_session_reuse = NGX_CONF_UNSET;
     conf->upstream.ssl_name = NGX_CONF_UNSET_PTR;
@@ -3432,6 +3538,11 @@ ngx_http_proxy_create_loc_conf(ngx_conf_t *cf)
     conf->headers_hash_max_size = NGX_CONF_UNSET_UINT;
     conf->headers_hash_bucket_size = NGX_CONF_UNSET_UINT;
 
+#if (NGX_HTTP_EXT)
+    conf->sndbuf = NGX_CONF_UNSET_SIZE;
+    conf->rcvbuf = NGX_CONF_UNSET_SIZE;
+#endif
+
     ngx_str_set(&conf->upstream.module, "proxy");
 
     return conf;
@@ -3447,6 +3558,10 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     u_char                     *p;
     size_t                      size;
     ngx_int_t                   rc;
+#if (NGX_HTTP_EXT)
+    ngx_uint_t                  i;
+    ngx_keyval_t               *src, *h;
+#endif
     ngx_hash_init_t             hash;
     ngx_http_core_loc_conf_t   *clcf;
     ngx_http_proxy_rewrite_t   *pr;
@@ -3518,6 +3633,11 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_ptr_value(conf->upstream.limit_rate,
                               prev->upstream.limit_rate, NULL);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_size_value(conf->sndbuf, prev->sndbuf, (size_t) 0);
+    ngx_conf_merge_size_value(conf->rcvbuf, prev->rcvbuf, (size_t) 0);
+#endif
+
     ngx_conf_merge_bufs_value(conf->upstream.bufs, prev->upstream.bufs,
                               8, ngx_pagesize);
 
@@ -3613,6 +3733,11 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
                               prev->upstream.ignore_headers,
                               NGX_CONF_BITMASK_SET);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_bitmask_value(conf->upstream.ignore_cache_control,
+                              prev->upstream.ignore_cache_control,
+                              NGX_CONF_BITMASK_SET);
+#endif
 
     ngx_conf_merge_bitmask_value(conf->upstream.next_upstream,
                               prev->upstream.next_upstream,
@@ -3656,6 +3781,11 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
         return NGX_CONF_ERROR;
     }
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_ptr_value(conf->upstream.cache_min_age,
+                              prev->upstream.cache_min_age, NULL);
+#endif
+
     ngx_conf_merge_uint_value(conf->upstream.cache_min_uses,
                               prev->upstream.cache_min_uses, 1);
 
@@ -3677,6 +3807,15 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
         conf->upstream.cache_use_stale |= NGX_HTTP_UPSTREAM_FT_NOLIVE;
     }
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_ptr_value(conf->upstream.cache_stale_if_error,
+                              prev->upstream.cache_stale_if_error,
+                              NULL);
+    ngx_conf_merge_ptr_value(conf->upstream.cache_stale_while_revalidate,
+                              prev->upstream.cache_stale_while_revalidate,
+                              NULL);
+#endif
+
     if (conf->upstream.cache_methods == 0) {
         conf->upstream.cache_methods = prev->upstream.cache_methods;
     }
@@ -3689,6 +3828,18 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_ptr_value(conf->upstream.no_cache,
                              prev->upstream.no_cache, NULL);
 
+#if (NGX_HTTP_EXT)
+    if (ngx_http_merge_types(cf, &conf->upstream.cache_types_keys,
+                             &conf->upstream.cache_types,
+                             &prev->upstream.cache_types_keys,
+                             &prev->upstream.cache_types,
+                             ngx_http_html_default_types)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+#endif
+
     ngx_conf_merge_ptr_value(conf->upstream.cache_valid,
                              prev->upstream.cache_valid, NULL);
 
@@ -3724,6 +3875,11 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_value(conf->upstream.intercept_errors,
                               prev->upstream.intercept_errors, 0);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_value(conf->headers_inherit,
+                              prev->headers_inherit, 0);
+#endif
+
 #if (NGX_HTTP_SSL)
 
     if (ngx_http_proxy_merge_ssl(cf, conf, prev) != NGX_OK) {
@@ -3905,6 +4061,27 @@ ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
 #if (NGX_HTTP_CACHE)
         conf->headers_cache = prev->headers_cache;
 #endif
+
+#if (NGX_HTTP_EXT)
+    } else if (conf->headers_source
+               && prev->headers_source
+               && prev->headers_source != NGX_CONF_UNSET_PTR)
+    {
+        src = prev->headers_source->elts;
+
+        for (i = 0; i < prev->headers_source->nelts; i++) {
+            if (!conf->headers_inherit) {
+                continue;
+            }
+
+            h = ngx_array_push(conf->headers_source);
+            if (h == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *h = src[i];
+        }
+#endif
     }
 
     rc = ngx_http_proxy_init_headers(cf, conf, &conf->headers,
diff --git a/src/http/modules/ngx_http_realip_module.c b/src/http/modules/ngx_http_realip_module.c
index f6731e7..885d93a 100644
--- a/src/http/modules/ngx_http_realip_module.c
+++ b/src/http/modules/ngx_http_realip_module.c
@@ -16,6 +16,20 @@
 #define NGX_HTTP_REALIP_PROXY    3
 
 
+#if (NGX_HTTP_EXT)
+typedef struct {
+    ngx_uint_t         type;
+    ngx_uint_t         hash;
+    ngx_str_t          name;
+} ngx_http_realip_header_t;
+
+
+typedef struct {
+    ngx_array_t       *from;     /* array of ngx_cidr_t */
+    ngx_array_t       *headers;
+    ngx_flag_t         recursive;
+} ngx_http_realip_loc_conf_t;
+#else
 typedef struct {
     ngx_array_t       *from;     /* array of ngx_cidr_t */
     ngx_uint_t         type;
@@ -23,6 +37,7 @@ typedef struct {
     ngx_str_t          header;
     ngx_flag_t         recursive;
 } ngx_http_realip_loc_conf_t;
+#endif
 
 
 typedef struct {
@@ -65,7 +80,11 @@ static ngx_command_t  ngx_http_realip_commands[] = {
       NULL },
 
     { ngx_string("real_ip_header"),
+#if (NGX_HTTP_EXT)
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+#else
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+#endif
       ngx_http_realip,
       NGX_HTTP_LOC_CONF_OFFSET,
       0,
@@ -133,12 +152,18 @@ ngx_http_realip_handler(ngx_http_request_t *r)
     size_t                       len;
     ngx_str_t                   *value;
     ngx_uint_t                   i, hash;
+#if (NGX_HTTP_EXT)
+    ngx_uint_t                   j;
+#endif
     ngx_addr_t                   addr;
     ngx_list_part_t             *part;
     ngx_table_elt_t             *header, *xfwd;
     ngx_connection_t            *c;
     ngx_http_realip_ctx_t       *ctx;
     ngx_http_realip_loc_conf_t  *rlcf;
+#if (NGX_HTTP_EXT)
+    ngx_http_realip_header_t    *realip_header;
+#endif
 
     rlcf = ngx_http_get_module_loc_conf(r, ngx_http_realip_module);
 
@@ -152,6 +177,81 @@ ngx_http_realip_handler(ngx_http_request_t *r)
         return NGX_DECLINED;
     }
 
+#if (NGX_HTTP_EXT)
+    value = NULL;
+    xfwd = NULL;
+
+    for (j = 0; j < rlcf->headers->nelts; j++) {
+        realip_header = &((ngx_http_realip_header_t *) rlcf->headers->elts)[j];
+
+        switch (realip_header->type) {
+
+        case NGX_HTTP_REALIP_XREALIP:
+
+            if (r->headers_in.x_real_ip != NULL) {
+                value = &r->headers_in.x_real_ip->value;
+                xfwd = NULL;
+                goto found;
+            }
+
+            break;
+
+        case NGX_HTTP_REALIP_XFWD:
+
+            if (r->headers_in.x_forwarded_for != NULL) {
+                xfwd = r->headers_in.x_forwarded_for;
+                value = NULL;
+                goto found;
+            }
+
+            break;
+
+        case NGX_HTTP_REALIP_PROXY:
+
+            if (r->connection->proxy_protocol != NULL) {
+                value = &r->connection->proxy_protocol->src_addr;
+                xfwd = NULL;
+                goto found;
+            }
+
+            break;
+
+        default: /* NGX_HTTP_REALIP_HEADER */
+
+            part = &r->headers_in.headers.part;
+            header = part->elts;
+
+            hash = realip_header->hash;
+            len = realip_header->name.len;
+            p = realip_header->name.data;
+
+            for (i = 0; /* void */ ; i++) {
+
+                if (i >= part->nelts) {
+                    if (part->next == NULL) {
+                        break;
+                    }
+
+                    part = part->next;
+                    header = part->elts;
+                    i = 0;
+                }
+
+                if (hash == header[i].hash
+                    && len == header[i].key.len
+                    && ngx_strncmp(p, header[i].lowcase_key, len) == 0)
+                {
+                    value = &header[i].value;
+                    xfwd = NULL;
+
+                    goto found;
+                }
+            }
+        }
+    }
+
+    return NGX_DECLINED;
+#else
     switch (rlcf->type) {
 
     case NGX_HTTP_REALIP_XREALIP:
@@ -222,6 +322,7 @@ ngx_http_realip_handler(ngx_http_request_t *r)
 
         return NGX_DECLINED;
     }
+#endif
 
 found:
 
@@ -235,7 +336,11 @@ found:
                                     rlcf->recursive)
         != NGX_DECLINED)
     {
+#if (NGX_HTTP_EXT)
+        if (realip_header->type == NGX_HTTP_REALIP_PROXY) {
+#else
         if (rlcf->type == NGX_HTTP_REALIP_PROXY) {
+#endif
             ngx_inet_set_port(addr.sockaddr, c->proxy_protocol->src_port);
         }
 
@@ -418,6 +523,39 @@ ngx_http_realip(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 {
     ngx_http_realip_loc_conf_t *rlcf = conf;
 
+#if (NGX_HTTP_EXT)
+    ngx_str_t                *value;
+    ngx_http_realip_header_t *header;
+    ngx_uint_t                i;
+
+    if (rlcf->headers == NULL) {
+        rlcf->headers = ngx_array_create(cf->pool, 4, sizeof(ngx_str_t));
+        if (rlcf->headers == NULL) {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    value = cf->args->elts;
+
+    for (i = 1; i < cf->args->nelts; i++) {
+        header = ngx_array_push(rlcf->headers);
+        if (header == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_strcmp(value[1].data, "X-Real-IP") == 0) {
+            header->type = NGX_HTTP_REALIP_XREALIP;
+        } else if (ngx_strcmp(value[1].data, "X-Forwarded-For") == 0) {
+            header->type = NGX_HTTP_REALIP_XFWD;
+        } else if (ngx_strcmp(value[1].data, "proxy_protocol") == 0) {
+            header->type = NGX_HTTP_REALIP_PROXY;
+        } else {
+            header->type = NGX_HTTP_REALIP_HEADER;
+            header->hash = ngx_hash_strlow(value[i].data, value[i].data, value[i].len);
+            header->name = value[i];
+        }
+    }
+#else
     ngx_str_t  *value;
 
     if (rlcf->type != NGX_CONF_UNSET_UINT) {
@@ -444,6 +582,7 @@ ngx_http_realip(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
     rlcf->type = NGX_HTTP_REALIP_HEADER;
     rlcf->hash = ngx_hash_strlow(value[1].data, value[1].data, value[1].len);
     rlcf->header = value[1];
+#endif
 
     return NGX_CONF_OK;
 }
@@ -463,11 +602,16 @@ ngx_http_realip_create_loc_conf(ngx_conf_t *cf)
      * set by ngx_pcalloc():
      *
      *     conf->from = NULL;
-     *     conf->hash = 0;
-     *     conf->header = { 0, NULL };
      */
 
+#if (NGX_HTTP_EXT)
+    conf->headers = ngx_array_create(cf->pool, 4, sizeof(ngx_http_realip_header_t));
+    if (conf->headers == NULL) {
+        return NGX_CONF_ERROR;
+    }
+#else
     conf->type = NGX_CONF_UNSET_UINT;
+#endif
     conf->recursive = NGX_CONF_UNSET;
 
     return conf;
@@ -484,13 +628,30 @@ ngx_http_realip_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
         conf->from = prev->from;
     }
 
+#if !(NGX_HTTP_EXT)
     ngx_conf_merge_uint_value(conf->type, prev->type, NGX_HTTP_REALIP_XREALIP);
+#endif
+
     ngx_conf_merge_value(conf->recursive, prev->recursive, 0);
 
+#if (NGX_HTTP_EXT)
+    if (conf->headers == NULL || conf->headers->nelts == 0) {
+        if (prev->headers == NULL || prev->headers->nelts == 0) {
+            ngx_http_realip_header_t *header = ngx_array_push(conf->headers);
+            if (header == NULL) {
+                return NGX_CONF_ERROR;
+            }
+            header->type = NGX_HTTP_REALIP_XREALIP;
+        } else {
+            conf->headers = prev->headers;
+        }
+    }
+#else
     if (conf->header.len == 0) {
         conf->hash = prev->hash;
         conf->header = prev->header;
     }
+#endif
 
     return NGX_CONF_OK;
 }
diff --git a/src/http/modules/ngx_http_rewrite_module.c b/src/http/modules/ngx_http_rewrite_module.c
index ff3b687..04e3830 100644
--- a/src/http/modules/ngx_http_rewrite_module.c
+++ b/src/http/modules/ngx_http_rewrite_module.c
@@ -19,6 +19,13 @@ typedef struct {
     ngx_flag_t    uninitialized_variable_warn;
 } ngx_http_rewrite_loc_conf_t;
 
+#if (NGX_HTTP_EXT)
+typedef struct {
+    ngx_http_script_if_op_e  op_type;
+    ngx_uint_t               op_index;
+} ngx_http_rewrite_if_operator_t;
+#endif
+
 
 static void *ngx_http_rewrite_create_loc_conf(ngx_conf_t *cf);
 static char *ngx_http_rewrite_merge_loc_conf(ngx_conf_t *cf,
@@ -40,6 +47,17 @@ static char *ngx_http_rewrite_set(ngx_conf_t *cf, ngx_command_t *cmd,
 static char * ngx_http_rewrite_value(ngx_conf_t *cf,
     ngx_http_rewrite_loc_conf_t *lcf, ngx_str_t *value);
 
+#if (NGX_HTTP_EXT)
+static char * ngx_http_rewrite_parse_if_condition(ngx_conf_t *cf,
+    ngx_http_rewrite_loc_conf_t *lcf,
+    ngx_str_t *value, ngx_uint_t begin, ngx_uint_t last);
+static char * ngx_http_rewrite_find_if_logic_operator(ngx_str_t * value,
+    ngx_uint_t begin, ngx_uint_t last,
+    ngx_http_rewrite_if_operator_t *operator);
+static char * ngx_http_rewrite_if_logic_item(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf,
+    ngx_uint_t cur, ngx_uint_t last);
+#endif
+
 
 static ngx_command_t  ngx_http_rewrite_commands[] = {
 
@@ -74,6 +92,22 @@ static ngx_command_t  ngx_http_rewrite_commands[] = {
       0,
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("elif"),
+      NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_BLOCK|NGX_CONF_1MORE,
+      ngx_http_rewrite_if,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("else"),
+      NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
+      ngx_http_rewrite_if,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      NULL },
+#endif
+
     { ngx_string("set"),
       NGX_HTTP_SRV_CONF|NGX_HTTP_SIF_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
                        |NGX_CONF_TAKE2,
@@ -175,6 +209,10 @@ ngx_http_rewrite_handler(ngx_http_request_t *r)
     e->log = rlcf->log;
     e->status = NGX_DECLINED;
 
+#if (NGX_HTTP_EXT)
+    e->if_matched = 1;
+#endif
+
     while (*(uintptr_t *) e->ip) {
         code = *(ngx_http_script_code_pt *) e->ip;
         code(e);
@@ -544,6 +582,12 @@ ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
     ngx_http_script_if_code_t    *if_code;
     ngx_http_rewrite_loc_conf_t  *nlcf;
 
+#if (NGX_HTTP_EXT)
+    ngx_str_t                    *value;
+    
+    value = cf->args->elts;
+#endif
+
     ctx = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t));
     if (ctx == NULL) {
         return NGX_CONF_ERROR;
@@ -587,16 +631,39 @@ ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
         return NGX_CONF_ERROR;
     }
 
+#if (NGX_HTTP_EXT)
+    /* 'else' does not require conditions */
+    if (value[0].len != 4 || ngx_strcmp(value[0].data, "else") != 0) {
+        if (ngx_http_rewrite_if_condition(cf, lcf) != NGX_CONF_OK) {
+            return NGX_CONF_ERROR;
+        }
+    }
+#else
     if (ngx_http_rewrite_if_condition(cf, lcf) != NGX_CONF_OK) {
         return NGX_CONF_ERROR;
     }
+#endif
 
     if_code = ngx_array_push_n(lcf->codes, sizeof(ngx_http_script_if_code_t));
     if (if_code == NULL) {
         return NGX_CONF_ERROR;
     }
 
+#if (NGX_HTTP_EXT)
+    if (value[0].len == 2 && ngx_strcmp(value[0].data, "if") == 0) {
+        if_code->code = ngx_http_script_if_code;
+    } else if (value[0].len == 4 && ngx_strcmp(value[0].data, "elif") == 0) {
+        if_code->code = ngx_http_script_elif_code;
+    } else if (value[0].len == 4 && ngx_strcmp(value[0].data, "else") == 0) {
+        if_code->code = ngx_http_script_else_code;
+    } else {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                            "invalid directive \"%V\"", &value[0]);
+        return NGX_CONF_ERROR;
+    }
+#else
     if_code->code = ngx_http_script_if_code;
+#endif
 
     elts = lcf->codes->elts;
 
@@ -644,6 +711,659 @@ ngx_http_rewrite_if(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 }
 
 
+#if (NGX_HTTP_EXT)
+static char *
+ngx_http_rewrite_if_logic_item(ngx_conf_t *cf,
+    ngx_http_rewrite_loc_conf_t *lcf, ngx_uint_t cur, ngx_uint_t last)
+{
+    u_char                        *p;
+    size_t                         len;
+    ngx_str_t                     *value;
+    ngx_regex_compile_t            rc;
+    ngx_http_script_code_pt       *code;
+    ngx_http_script_file_code_t   *fop;
+    ngx_http_script_regex_code_t  *regex;
+    u_char                         errstr[NGX_MAX_CONF_ERRSTR];
+
+    if (cur > last) {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                "item begin index %u is larger than the end index %u",
+                cur, last);
+        return NGX_CONF_ERROR;
+    }
+
+    value = cf->args->elts;
+
+    len = value[cur].len;
+    p = value[cur].data;
+
+    if (len > 1 && p[0] == '$') {
+
+        if (cur != last && cur + 2 != last) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "invalid condition \"%V\"", &value[cur]);
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_http_rewrite_variable(cf, lcf, &value[cur]) != NGX_CONF_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (cur == last) {
+            return NGX_CONF_OK;
+        }
+
+        cur++;
+
+        len = value[cur].len;
+        p = value[cur].data;
+
+        if (len == 1 && p[0] == '=') {
+
+            if (ngx_http_rewrite_value(cf, lcf, &value[last]) != NGX_CONF_OK) {
+                return NGX_CONF_ERROR;
+            }
+
+            code = ngx_http_script_start_code(cf->pool, &lcf->codes,
+                                              sizeof(uintptr_t));
+            if (code == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *code = ngx_http_script_equal_code;
+
+            return NGX_CONF_OK;
+        }
+
+        if (len == 2 && p[0] == '!' && p[1] == '=') {
+
+            if (ngx_http_rewrite_value(cf, lcf, &value[last]) != NGX_CONF_OK) {
+                return NGX_CONF_ERROR;
+            }
+
+            code = ngx_http_script_start_code(cf->pool, &lcf->codes,
+                                              sizeof(uintptr_t));
+            if (code == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *code = ngx_http_script_not_equal_code;
+            return NGX_CONF_OK;
+        }
+
+        if ((len == 1 && p[0] == '~')
+            || (len == 2 && p[0] == '~' && p[1] == '*')
+            || (len == 2 && p[0] == '!' && p[1] == '~')
+            || (len == 3 && p[0] == '!' && p[1] == '~' && p[2] == '*'))
+        {
+            regex = ngx_http_script_start_code(cf->pool, &lcf->codes,
+                                         sizeof(ngx_http_script_regex_code_t));
+            if (regex == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            ngx_memzero(regex, sizeof(ngx_http_script_regex_code_t));
+
+            ngx_memzero(&rc, sizeof(ngx_regex_compile_t));
+
+            rc.pattern = value[last];
+            rc.options = (p[len - 1] == '*') ? NGX_REGEX_CASELESS : 0;
+            rc.err.len = NGX_MAX_CONF_ERRSTR;
+            rc.err.data = errstr;
+
+            regex->regex = ngx_http_regex_compile(cf, &rc);
+            if (regex->regex == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            regex->code = ngx_http_script_regex_start_code;
+            regex->next = sizeof(ngx_http_script_regex_code_t);
+            regex->test = 1;
+            if (p[0] == '!') {
+                regex->negative_test = 1;
+            }
+            regex->name = value[last];
+
+            return NGX_CONF_OK;
+        }
+
+        if (len == 1 && p[0] == '>') {
+
+            if (ngx_http_rewrite_value(cf, lcf, &value[last]) != NGX_CONF_OK) {
+                return NGX_CONF_ERROR;
+            }
+
+            code = ngx_http_script_start_code(cf->pool, &lcf->codes,
+                    sizeof(uintptr_t));
+
+            if (code == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *code = ngx_http_script_greater_than_code;
+            return NGX_CONF_OK;
+
+        }
+
+        if (len == 1 && p[0] == '<') {
+
+            if (ngx_http_rewrite_value(cf, lcf, &value[last]) != NGX_CONF_OK) {
+                return NGX_CONF_ERROR;
+            }
+
+            code = ngx_http_script_start_code(cf->pool, &lcf->codes,
+                    sizeof(uintptr_t));
+
+            if (code == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *code = ngx_http_script_less_than_code;
+            return NGX_CONF_OK;
+        }
+
+        if (len == 2 && ((p[0] == '!' && p[1] == '<')
+                || (p[0] == '>' && p[1] == '='))) {
+
+            if (ngx_http_rewrite_value(cf, lcf, &value[last]) != NGX_CONF_OK) {
+                return NGX_CONF_ERROR;
+            }
+
+            code = ngx_http_script_start_code(cf->pool, &lcf->codes,
+                    sizeof(uintptr_t));
+
+            if (code == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *code = ngx_http_script_greater_equal_code;
+            return NGX_CONF_OK;
+        }
+
+        if (len == 2 && ((p[0] == '!' && p[1] == '>')
+                || (p[0] == '<' && p[1] == '='))) {
+
+            if (ngx_http_rewrite_value(cf, lcf, &value[last]) != NGX_CONF_OK) {
+                return NGX_CONF_ERROR;
+            }
+
+            code = ngx_http_script_start_code(cf->pool, &lcf->codes,
+                    sizeof(uintptr_t));
+
+            if (code == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *code = ngx_http_script_less_equal_code;
+
+            return NGX_CONF_OK;
+        }
+
+        if (len == 2 && p[0] == '^' && p[1] == '~') {
+
+            if (ngx_http_rewrite_value(cf, lcf, &value[last]) != NGX_CONF_OK) {
+                return NGX_CONF_ERROR;
+            }
+
+            code = ngx_http_script_start_code(cf->pool, &lcf->codes,
+                    sizeof(uintptr_t));
+
+            if (code == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *code = ngx_http_script_start_with_code;
+            return NGX_CONF_OK;
+        }
+
+        if (len == 3 && p[0] == '!' && p[1] == '^' && p[2] == '~') {
+
+            if (ngx_http_rewrite_value(cf, lcf, &value[last]) != NGX_CONF_OK) {
+                return NGX_CONF_ERROR;
+            }
+
+            code = ngx_http_script_start_code(cf->pool, &lcf->codes,
+                    sizeof(uintptr_t));
+
+            if (code == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            *code = ngx_http_script_not_start_with_code;
+            return NGX_CONF_OK;
+        }
+
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "unexpected \"%V\" in condition", &value[cur]);
+        return NGX_CONF_ERROR;
+
+    } else if ((len == 2 && p[0] == '-')
+               || (len == 3 && p[0] == '!' && p[1] == '-'))
+    {
+        if (cur + 1 != last) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "invalid condition \"%V\"", &value[cur]);
+            return NGX_CONF_ERROR;
+        }
+
+        value[last].data[value[last].len] = '\0';
+        value[last].len++;
+
+        if (ngx_http_rewrite_value(cf, lcf, &value[last]) != NGX_CONF_OK) {
+            return NGX_CONF_ERROR;
+        }
+
+        fop = ngx_http_script_start_code(cf->pool, &lcf->codes,
+                                          sizeof(ngx_http_script_file_code_t));
+        if (fop == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        fop->code = ngx_http_script_file_code;
+
+        if (p[1] == 'f') {
+            fop->op = ngx_http_script_file_plain;
+            return NGX_CONF_OK;
+        }
+
+        if (p[1] == 'd') {
+            fop->op = ngx_http_script_file_dir;
+            return NGX_CONF_OK;
+        }
+
+        if (p[1] == 'e') {
+            fop->op = ngx_http_script_file_exists;
+            return NGX_CONF_OK;
+        }
+
+        if (p[1] == 'x') {
+            fop->op = ngx_http_script_file_exec;
+            return NGX_CONF_OK;
+        }
+
+        if (p[0] == '!') {
+            if (p[2] == 'f') {
+                fop->op = ngx_http_script_file_not_plain;
+                return NGX_CONF_OK;
+            }
+
+            if (p[2] == 'd') {
+                fop->op = ngx_http_script_file_not_dir;
+                return NGX_CONF_OK;
+            }
+
+            if (p[2] == 'e') {
+                fop->op = ngx_http_script_file_not_exists;
+                return NGX_CONF_OK;
+            }
+
+            if (p[2] == 'x') {
+                fop->op = ngx_http_script_file_not_exec;
+                return NGX_CONF_OK;
+            }
+        }
+
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "invalid condition \"%V\"", &value[cur]);
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                       "invalid condition \"%V\"", &value[cur]);
+
+    return NGX_CONF_ERROR;
+}
+
+
+static ngx_http_script_if_op_e
+ngx_http_rewrite_if_check_operator(ngx_str_t *value)
+{
+    if (value == NULL) {
+        return ngx_http_script_if_invalid;
+    }
+
+    if (value->len == 2) {
+        if (ngx_strncmp(value->data, "||", 2) == 0){
+            return ngx_http_script_if_or;
+        } else if (ngx_strncmp(value->data, "&&", 2) == 0){
+            return ngx_http_script_if_and;
+        }
+    }
+
+    return ngx_http_script_if_invalid;
+}
+
+
+static char *
+ngx_http_rewrite_find_if_logic_operator(ngx_str_t *value, ngx_uint_t begin,
+    ngx_uint_t last, ngx_http_rewrite_if_operator_t *operator)
+{
+    ngx_http_script_if_op_e op_type = ngx_http_script_if_invalid;
+
+    if (value == NULL || begin > last || operator == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    operator->op_type = op_type;
+    operator->op_index = 0;
+
+    while (begin <= last) {
+        op_type = ngx_http_rewrite_if_check_operator(&value[begin]);
+
+        if (op_type != ngx_http_script_if_invalid) {
+            operator->op_type = op_type;
+            operator->op_index = begin;
+            return NGX_CONF_OK;
+        }
+
+        begin++;
+    }
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_http_rewrite_if_match_bracket(ngx_str_t *value, ngx_uint_t begin,
+        ngx_uint_t last, ngx_uint_t *index)
+{
+    /* When we run into this logic, the first character
+    * of the begin must be '('
+    * which is guaranteed before calling this function.
+    *
+    * The logic is quite simple: when finding a '(', the score
+    * increases by 1 and decreases by 1 if a ')' is found. Will return
+    * if the score is zero, which means the '(' and ')' are matching.
+    */
+
+    ngx_uint_t   match_score = 1;
+    ngx_uint_t   len = 0;
+    ngx_uint_t   pos, i;
+    u_char      *token_item = NULL;
+    ngx_int_t    valid;
+    ngx_str_t    prev_value;
+
+    if (value == NULL || begin > last || index == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (value[begin].len < 1 || value[begin].data[0] != '(') {
+        return NGX_CONF_ERROR;
+    }
+
+    /* skip the first one which is a '(' */
+    len = value[begin].len - 1;
+    token_item = value[begin].data + 1;
+
+    while (begin <= last) {
+        while (len) {
+            pos = value[begin].len - len;
+
+            if (*token_item == '(') {
+                if (pos == 0) {
+                    /* check the previous value for validity */
+                    if (begin > 0) {
+                        prev_value = value[begin - 1];
+                        if ((prev_value.len == 2 && (ngx_strncmp(prev_value.data, "&&", 2) == 0 || ngx_strncmp(prev_value.data, "||", 2) == 0))
+                            || (prev_value.len == 1 && prev_value.data[0] == '(')) {
+                            match_score++;
+                        }
+                    } else {
+                        match_score++;
+                    }
+                } else {
+                    valid = 1;
+                    for (i = 0; i < pos; i++) {
+                        if (value[begin].data[i] != '(') {
+                            valid = 0;
+                            break;
+                        }
+                    }
+                    if (valid) {
+                        match_score++;
+                    }
+                }
+            } else if (*token_item == ')') {
+
+                /* TODO: Avoid recognizing closing parentheses in strings or regular expressions */
+
+                if (pos != value[begin].len - 1) {
+                    valid = 1;
+                    for (i = pos + 1; i < value[begin].len; i++) {
+                        if (value[begin].data[i] != ')') {
+                            valid = 0;
+                            break;
+                        }
+                    }
+                    if (valid) {
+                        match_score--;
+                    }
+                } else {
+                    match_score--;
+                }
+            }
+
+            len--;
+            token_item++;
+        }
+
+        /* find the mathing */
+        if (match_score == 0) {
+            *index = begin;
+            /* the one in begin +1 must be operator */
+            return NGX_CONF_OK;
+        }
+
+        begin++;
+
+        /* try with next one */
+        len = value[begin].len;
+        token_item = value[begin].data;
+    }
+
+    return NGX_CONF_ERROR;
+}
+
+
+static char *
+ngx_http_rewrite_parse_if_condition(ngx_conf_t *cf,
+        ngx_http_rewrite_loc_conf_t *lcf,
+        ngx_str_t *value, ngx_uint_t begin, ngx_uint_t last)
+{
+    ngx_uint_t                       index, orig_index;
+    ngx_http_rewrite_if_operator_t   operator = {0};
+    char                            *rv;
+    ngx_http_script_if_op_e          op_type;
+
+    ngx_http_script_if_operator_code_t *operator_code;
+
+    rv = NGX_CONF_OK;
+    op_type = ngx_http_script_if_invalid;
+
+    /* find the matching ')' */
+    if (value[begin].data[0] == '(') {
+        rv = ngx_http_rewrite_if_match_bracket(value, begin, last, &index);
+        if (rv != NGX_CONF_OK) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                    "find match bracket error at position %ui", begin);
+            return rv;
+        }
+
+        orig_index = index;
+        if (value[begin].len == 1) {
+            begin++;
+        } else {
+            value[begin].len--;
+            value[begin].data++;
+        }
+
+        if (value[index].len == 1) {
+            index--;
+        } else {
+            value[index].data[value[index].len] = '\0';
+            value[index].len--;
+        }
+    
+        /* the matching bracket is at the end of the tokens */
+        rv = ngx_http_rewrite_parse_if_condition(cf, lcf, value, begin, index);
+
+        /* if op_type has validate value, then add the opcode */
+        if (rv != NGX_CONF_OK) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                    "find parse if condition error after parsing subcondition");
+            return rv;
+        }
+
+        index = orig_index;
+
+        if (index == last) {
+            return rv;
+        } else if (index < last - 2) {
+            /* still have some tokens left */
+            /* The first one after index must be operator */
+            op_type = ngx_http_rewrite_if_check_operator(&value[index + 1]);
+
+            if (op_type == ngx_http_script_if_invalid) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "two subconditions are adjacent "
+                        "without logic operator at position %ui", index + 1);
+                return NGX_CONF_ERROR;
+            }
+
+            begin = index + 2;
+            rv = ngx_http_rewrite_parse_if_condition(cf, lcf, value,
+                begin, last);
+            if (rv != NGX_CONF_OK) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "find parse if condition error "
+                        "after parsing right subcondition");
+                return rv;
+            }
+
+            operator.op_type = op_type;
+            operator.op_index = index;
+
+            /* add the operator operation here */
+            operator_code = ngx_array_push_n(lcf->codes,
+                    sizeof(ngx_http_script_if_operator_code_t));
+            if (operator_code == NULL) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "failed to allocate memory for operator code");
+                return NGX_CONF_ERROR;
+            }
+
+            operator_code->code = ngx_http_script_if_operator_code;
+            operator_code->op = op_type;
+            op_type = operator.op_type;
+            return rv;
+        } else {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                    "if conditions parsing error: "
+                    "unexpected token position at index=%ui, last=%ui",
+                    index, last);
+            return NGX_CONF_ERROR;
+        }
+
+    } else {
+        /* find the index of the operator */
+        rv = ngx_http_rewrite_find_if_logic_operator(value, begin,
+                last, &operator);
+        if (rv != NGX_CONF_OK) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                    "internal if logic operator finding error");
+            return rv;
+        }
+
+        /* no any opeators anymore */
+        if (operator.op_type == ngx_http_script_if_invalid) {
+            rv = ngx_http_rewrite_if_logic_item(cf, lcf, begin, last);
+            if (rv != NGX_CONF_OK) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "internal if logic subcondition parsing error");
+            }
+            return rv;
+        } else {
+            /* find the operator */
+            rv = ngx_http_rewrite_if_logic_item(cf, lcf, begin,
+                operator.op_index - 1);
+            if (rv != NGX_CONF_OK) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "internal if logic subcondition parsing error");
+                return rv;
+            }
+
+            begin = operator.op_index + 1;
+            rv = ngx_http_rewrite_parse_if_condition(cf, lcf, value,
+                begin, last);
+            if (rv != NGX_CONF_OK) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "internal if logic subcondition parsing error"
+                        "after parsing right subcondition");
+                return rv;
+            }
+
+            /* add the operator operation here. */
+            operator_code = ngx_array_push_n(lcf->codes,
+                    sizeof(ngx_http_script_if_operator_code_t));
+            if (operator_code == NULL) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                        "failed to allocate memory for operator code");
+                return NGX_CONF_ERROR;
+            }
+
+            operator_code->code = ngx_http_script_if_operator_code;
+            operator_code->op = operator.op_type;
+            return rv;
+        }
+    }
+
+    return rv;
+}
+
+
+static char *
+ngx_http_rewrite_if_condition(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf)
+{
+    char                  *rv;
+    ngx_str_t             *value;
+    ngx_uint_t             cur, last;
+
+    value = cf->args->elts;
+    last = cf->args->nelts - 1;
+
+    if (value[1].len < 1 || value[1].data[0] != '(') {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "invalid condition \"%V\"", &value[1]);
+        return NGX_CONF_ERROR;
+    }
+
+    if (value[1].len == 1) {
+        cur = 2;
+
+    } else {
+        cur = 1;
+        value[1].len--;
+        value[1].data++;
+    }
+
+    if (value[last].len < 1 || value[last].data[value[last].len - 1] != ')') {
+        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                           "invalid condition \"%V\"", &value[last]);
+        return NGX_CONF_ERROR;
+    }
+
+    if (value[last].len == 1) {
+        last--;
+
+    } else {
+        value[last].len--;
+        value[last].data[value[last].len] = '\0';
+    }
+
+    rv = ngx_http_rewrite_parse_if_condition(cf, lcf, value, cur, last);
+
+    return rv;
+}
+#else
 static char *
 ngx_http_rewrite_if_condition(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf)
 {
@@ -862,6 +1582,7 @@ ngx_http_rewrite_if_condition(ngx_conf_t *cf, ngx_http_rewrite_loc_conf_t *lcf)
 
     return NGX_CONF_ERROR;
 }
+#endif
 
 
 static char *
diff --git a/src/http/modules/ngx_http_scgi_module.c b/src/http/modules/ngx_http_scgi_module.c
index f818fc4..3415b8d 100644
--- a/src/http/modules/ngx_http_scgi_module.c
+++ b/src/http/modules/ngx_http_scgi_module.c
@@ -40,6 +40,11 @@ typedef struct {
 #if (NGX_HTTP_CACHE)
     ngx_http_complex_value_t   cache_key;
 #endif
+
+#if (NGX_HTTP_EXT)
+    size_t                     sndbuf;
+    size_t                     rcvbuf;
+#endif
 } ngx_http_scgi_loc_conf_t;
 
 
@@ -265,6 +270,15 @@ static ngx_command_t ngx_http_scgi_commands[] = {
       offsetof(ngx_http_scgi_loc_conf_t, upstream.no_cache),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("scgi_cache_types"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_http_types_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_scgi_loc_conf_t, upstream.cache_types_keys),
+      &ngx_http_html_default_types[0] },
+#endif
+
     { ngx_string("scgi_cache_valid"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
       ngx_http_file_cache_valid_set_slot,
@@ -272,6 +286,15 @@ static ngx_command_t ngx_http_scgi_commands[] = {
       offsetof(ngx_http_scgi_loc_conf_t, upstream.cache_valid),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("scgi_cache_min_age"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_http_set_complex_value_sec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_scgi_loc_conf_t, upstream.cache_min_age),
+      NULL },
+#endif
+
     { ngx_string("scgi_cache_min_uses"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_num_slot,
@@ -293,6 +316,23 @@ static ngx_command_t ngx_http_scgi_commands[] = {
       offsetof(ngx_http_scgi_loc_conf_t, upstream.cache_use_stale),
       &ngx_http_scgi_next_upstream_masks },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("scgi_cache_stale_if_error"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_set_complex_value_sec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_scgi_loc_conf_t, upstream.cache_stale_if_error),
+      NULL },
+
+    { ngx_string("scgi_cache_stale_while_revalidate"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_set_complex_value_sec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_scgi_loc_conf_t,
+                upstream.cache_stale_while_revalidate),
+      NULL },
+#endif
+
     { ngx_string("scgi_cache_methods"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
       ngx_conf_set_bitmask_slot,
@@ -407,6 +447,29 @@ static ngx_command_t ngx_http_scgi_commands[] = {
       offsetof(ngx_http_scgi_loc_conf_t, upstream.ignore_headers),
       &ngx_http_upstream_ignore_headers_masks },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("scgi_ignore_cache_control"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_conf_set_bitmask_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_scgi_loc_conf_t, upstream.ignore_cache_control),
+      &ngx_http_upstream_ignore_cache_control_masks },
+
+    { ngx_string("scgi_sndbuf_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_scgi_loc_conf_t, sndbuf),
+      NULL },
+
+    { ngx_string("scgi_rcvbuf_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_scgi_loc_conf_t, rcvbuf),
+      NULL },
+#endif
+
       ngx_null_command
 };
 
@@ -527,6 +590,16 @@ ngx_http_scgi_handler(ngx_http_request_t *r)
 
     u->buffering = scf->upstream.buffering;
 
+#if (NGX_HTTP_EXT)
+    if (scf->sndbuf > 0) {
+        u->peer.sndbuf = scf->sndbuf;
+    }
+
+    if (scf->rcvbuf > 0) {
+        u->peer.rcvbuf = scf->rcvbuf;
+    }
+#endif
+
     u->pipe = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t));
     if (u->pipe == NULL) {
         return NGX_HTTP_INTERNAL_SERVER_ERROR;
@@ -1312,7 +1385,14 @@ ngx_http_scgi_create_loc_conf(ngx_conf_t *cf)
 
 #if (NGX_HTTP_CACHE)
     conf->upstream.cache = NGX_CONF_UNSET;
+#if (NGX_HTTP_EXT)
+    conf->upstream.cache_min_age = NGX_CONF_UNSET_PTR;
+#endif
     conf->upstream.cache_min_uses = NGX_CONF_UNSET_UINT;
+#if (NGX_HTTP_EXT)
+    conf->upstream.cache_stale_if_error = NGX_CONF_UNSET_PTR;
+    conf->upstream.cache_stale_while_revalidate = NGX_CONF_UNSET_PTR;
+#endif
     conf->upstream.cache_max_range_offset = NGX_CONF_UNSET;
     conf->upstream.cache_bypass = NGX_CONF_UNSET_PTR;
     conf->upstream.no_cache = NGX_CONF_UNSET_PTR;
@@ -1334,6 +1414,11 @@ ngx_http_scgi_create_loc_conf(ngx_conf_t *cf)
 
     conf->upstream.change_buffering = 1;
 
+#if (NGX_HTTP_EXT)
+    conf->sndbuf = NGX_CONF_UNSET_SIZE;
+    conf->rcvbuf = NGX_CONF_UNSET_SIZE;
+#endif
+
     ngx_str_set(&conf->upstream.module, "scgi");
 
     return conf;
@@ -1416,6 +1501,10 @@ ngx_http_scgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_ptr_value(conf->upstream.limit_rate,
                               prev->upstream.limit_rate, NULL);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_size_value(conf->sndbuf, prev->sndbuf, (size_t) 0);
+    ngx_conf_merge_size_value(conf->rcvbuf, prev->rcvbuf, (size_t) 0);
+#endif
 
     ngx_conf_merge_bufs_value(conf->upstream.bufs, prev->upstream.bufs,
                               8, ngx_pagesize);
@@ -1513,6 +1602,11 @@ ngx_http_scgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
                                  prev->upstream.ignore_headers,
                                  NGX_CONF_BITMASK_SET);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_bitmask_value(conf->upstream.ignore_cache_control,
+                              prev->upstream.ignore_cache_control,
+                              NGX_CONF_BITMASK_SET);
+#endif
 
     ngx_conf_merge_bitmask_value(conf->upstream.next_upstream,
                                  prev->upstream.next_upstream,
@@ -1555,6 +1649,11 @@ ngx_http_scgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
         return NGX_CONF_ERROR;
     }
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_ptr_value(conf->upstream.cache_min_age,
+                              prev->upstream.cache_min_age, NULL);
+#endif
+
     ngx_conf_merge_uint_value(conf->upstream.cache_min_uses,
                               prev->upstream.cache_min_uses, 1);
 
@@ -1576,6 +1675,15 @@ ngx_http_scgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
         conf->upstream.cache_use_stale |= NGX_HTTP_UPSTREAM_FT_NOLIVE;
     }
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_ptr_value(conf->upstream.cache_stale_if_error,
+                              prev->upstream.cache_stale_if_error,
+                              NULL);
+    ngx_conf_merge_ptr_value(conf->upstream.cache_stale_while_revalidate,
+                              prev->upstream.cache_stale_while_revalidate,
+                              NULL);
+#endif
+
     if (conf->upstream.cache_methods == 0) {
         conf->upstream.cache_methods = prev->upstream.cache_methods;
     }
@@ -1588,6 +1696,18 @@ ngx_http_scgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_ptr_value(conf->upstream.no_cache,
                              prev->upstream.no_cache, NULL);
 
+#if (NGX_HTTP_EXT)
+    if (ngx_http_merge_types(cf, &conf->upstream.cache_types_keys,
+                             &conf->upstream.cache_types,
+                             &prev->upstream.cache_types_keys,
+                             &prev->upstream.cache_types,
+                             ngx_http_html_default_types)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+#endif
+
     ngx_conf_merge_ptr_value(conf->upstream.cache_valid,
                              prev->upstream.cache_valid, NULL);
 
diff --git a/src/http/modules/ngx_http_slice_filter_module.c b/src/http/modules/ngx_http_slice_filter_module.c
index 186380a..422443f 100644
--- a/src/http/modules/ngx_http_slice_filter_module.c
+++ b/src/http/modules/ngx_http_slice_filter_module.c
@@ -12,6 +12,11 @@
 
 typedef struct {
     size_t               size;
+#if (NGX_HTTP_EXT)
+    ngx_uint_t           allow_methods;
+    ngx_flag_t           check_etag;
+    ngx_flag_t           check_last_modified;
+#endif
 } ngx_http_slice_loc_conf_t;
 
 
@@ -20,6 +25,9 @@ typedef struct {
     off_t                end;
     ngx_str_t            range;
     ngx_str_t            etag;
+#if (NGX_HTTP_EXT)
+    ngx_str_t            last_modified;
+#endif
     unsigned             last:1;
     unsigned             active:1;
     ngx_http_request_t  *sr;
@@ -48,6 +56,27 @@ static ngx_int_t ngx_http_slice_add_variables(ngx_conf_t *cf);
 static ngx_int_t ngx_http_slice_init(ngx_conf_t *cf);
 
 
+#if (NGX_HTTP_EXT)
+static ngx_conf_bitmask_t  ngx_http_slice_allow_methods_mask[] = {
+    { ngx_string("GET"),      NGX_HTTP_GET },
+    { ngx_string("HEAD"),     NGX_HTTP_HEAD },
+    { ngx_string("POST"),     NGX_HTTP_POST },
+    { ngx_string("PUT"),      NGX_HTTP_PUT },
+    { ngx_string("DELETE"),   NGX_HTTP_DELETE },
+    { ngx_string("MKCOL"),    NGX_HTTP_MKCOL },
+    { ngx_string("COPY"),     NGX_HTTP_COPY },
+    { ngx_string("MOVE"),     NGX_HTTP_MOVE },
+    { ngx_string("OPTIONS"),  NGX_HTTP_OPTIONS },
+    { ngx_string("PROPFIND"), NGX_HTTP_PROPFIND },
+    { ngx_string("LOCK"),     NGX_HTTP_LOCK },
+    { ngx_string("UNLOCK"),   NGX_HTTP_UNLOCK },
+    { ngx_string("PATCH"),    NGX_HTTP_PATCH },
+    { ngx_string("TRACE"),    NGX_HTTP_TRACE },
+    { ngx_null_string, 0 }
+};
+#endif
+
+
 static ngx_command_t  ngx_http_slice_filter_commands[] = {
 
     { ngx_string("slice"),
@@ -57,6 +86,29 @@ static ngx_command_t  ngx_http_slice_filter_commands[] = {
       offsetof(ngx_http_slice_loc_conf_t, size),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("slice_allow_methods"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_conf_set_bitmask_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_slice_loc_conf_t, allow_methods),
+      &ngx_http_slice_allow_methods_mask },
+
+    { ngx_string("slice_check_etag"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_slice_loc_conf_t, check_etag),
+      NULL },
+
+    { ngx_string("slice_check_last_modified"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_slice_loc_conf_t, check_last_modified),
+      NULL },
+#endif
+
       ngx_null_command
 };
 
@@ -113,6 +165,14 @@ ngx_http_slice_header_filter(ngx_http_request_t *r)
         return ngx_http_next_header_filter(r);
     }
 
+#if (NGX_HTTP_EXT)
+    slcf = ngx_http_get_module_loc_conf(r, ngx_http_slice_filter_module);
+
+    if (!(r->method & slcf->allow_methods)) {
+        return ngx_http_next_header_filter(r);
+    }
+#endif
+
     if (r->headers_out.status != NGX_HTTP_PARTIAL_CONTENT) {
         if (r == r->main) {
             ngx_http_set_ctx(r, NULL, ngx_http_slice_filter_module);
@@ -125,6 +185,47 @@ ngx_http_slice_header_filter(ngx_http_request_t *r)
         return NGX_ERROR;
     }
 
+#if (NGX_HTTP_EXT)
+    if (slcf->check_etag) {
+        h = r->headers_out.etag;
+
+        if (ctx->etag.len) {
+            if (h == NULL
+                || h->value.len != ctx->etag.len
+                || ngx_strncmp(h->value.data, ctx->etag.data, ctx->etag.len)
+                != 0)
+            {
+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                            "etag mismatch in slice response");
+                return NGX_ERROR;
+            }
+        }
+
+        if (h) {
+            ctx->etag = h->value;
+        }
+    }
+
+    if (slcf->check_last_modified) {
+        h = r->headers_out.last_modified;
+
+        if (ctx->last_modified.len) {
+            if (h == NULL
+                || h->value.len != ctx->last_modified.len
+                || ngx_strncmp(h->value.data, ctx->last_modified.data, ctx->last_modified.len)
+                != 0)
+            {
+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                            "last_modified mismatch in slice response");
+                return NGX_ERROR;
+            }
+        }
+
+        if (h) {
+            ctx->last_modified = h->value;
+        }
+    }
+#else
     h = r->headers_out.etag;
 
     if (ctx->etag.len) {
@@ -142,6 +243,7 @@ ngx_http_slice_header_filter(ngx_http_request_t *r)
     if (h) {
         ctx->etag = h->value;
     }
+#endif
 
     if (ngx_http_slice_parse_content_range(r, &cr) != NGX_OK) {
         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
@@ -159,7 +261,9 @@ ngx_http_slice_header_filter(ngx_http_request_t *r)
                    "http slice response range: %O-%O/%O",
                    cr.start, cr.end, cr.complete_length);
 
+#if !(NGX_HTTP_EXT)
     slcf = ngx_http_get_module_loc_conf(r, ngx_http_slice_filter_module);
+#endif
 
     end = ngx_min(cr.start + (off_t) slcf->size, cr.complete_length);
 
@@ -228,6 +332,14 @@ ngx_http_slice_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
         return ngx_http_next_body_filter(r, in);
     }
 
+#if (NGX_HTTP_EXT)
+    slcf = ngx_http_get_module_loc_conf(r, ngx_http_slice_filter_module);
+
+    if (!(r->method & slcf->allow_methods)) {
+        return ngx_http_next_body_filter(r, in);
+    }
+#endif
+
     for (cl = in; cl; cl = cl->next) {
         if (cl->buf->last_buf) {
             cl->buf->last_buf = 0;
@@ -272,7 +384,9 @@ ngx_http_slice_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
 
     ngx_http_set_ctx(ctx->sr, ctx, ngx_http_slice_filter_module);
 
+#if !(NGX_HTTP_EXT)
     slcf = ngx_http_get_module_loc_conf(r, ngx_http_slice_filter_module);
+#endif
 
     ctx->range.len = ngx_sprintf(ctx->range.data, "bytes=%O-%O", ctx->start,
                                  ctx->start + (off_t) slcf->size - 1)
@@ -399,6 +513,15 @@ ngx_http_slice_range_variable(ngx_http_request_t *r,
     ngx_http_slice_ctx_t       *ctx;
     ngx_http_slice_loc_conf_t  *slcf;
 
+#if (NGX_HTTP_EXT)
+    slcf = ngx_http_get_module_loc_conf(r, ngx_http_slice_filter_module);
+
+    if (!(r->method & slcf->allow_methods)) {
+        v->not_found = 1;
+        return NGX_OK;
+    }
+#endif
+
     ctx = ngx_http_get_module_ctx(r, ngx_http_slice_filter_module);
 
     if (ctx == NULL) {
@@ -407,7 +530,9 @@ ngx_http_slice_range_variable(ngx_http_request_t *r,
             return NGX_OK;
         }
 
+#if !(NGX_HTTP_EXT)
         slcf = ngx_http_get_module_loc_conf(r, ngx_http_slice_filter_module);
+#endif
 
         if (slcf->size == 0) {
             v->not_found = 1;
@@ -505,6 +630,12 @@ ngx_http_slice_create_loc_conf(ngx_conf_t *cf)
 
     slcf->size = NGX_CONF_UNSET_SIZE;
 
+#if (NGX_HTTP_EXT)
+    slcf->allow_methods = 0;
+    slcf->check_etag = NGX_CONF_UNSET;
+    slcf->check_last_modified = NGX_CONF_UNSET;
+#endif
+
     return slcf;
 }
 
@@ -517,6 +648,17 @@ ngx_http_slice_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
 
     ngx_conf_merge_size_value(conf->size, prev->size, 0);
 
+#if (NGX_HTTP_EXT)
+    if (conf->allow_methods == 0) {
+        conf->allow_methods = prev->allow_methods;
+    }
+    conf->allow_methods |= NGX_HTTP_GET|NGX_HTTP_HEAD;
+
+    ngx_conf_merge_off_value(conf->check_etag, prev->check_etag, 1);
+
+    ngx_conf_merge_off_value(conf->check_last_modified, prev->check_last_modified, 0);
+#endif
+
     return NGX_CONF_OK;
 }
 
diff --git a/src/http/modules/ngx_http_ssl_module.c b/src/http/modules/ngx_http_ssl_module.c
index 1c92d9f..a5c7368 100644
--- a/src/http/modules/ngx_http_ssl_module.c
+++ b/src/http/modules/ngx_http_ssl_module.c
@@ -290,6 +290,43 @@ static ngx_command_t  ngx_http_ssl_commands[] = {
       offsetof(ngx_http_ssl_srv_conf_t, reject_handshake),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("ssl_dyn_rec"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, dyn_rec_enable),
+      NULL },
+
+    { ngx_string("ssl_dyn_rec_timeout"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_msec_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, dyn_rec_timeout),
+      NULL },
+
+    { ngx_string("ssl_dyn_rec_size_lo"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, dyn_rec_size_lo),
+      NULL },
+
+    { ngx_string("ssl_dyn_rec_size_hi"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, dyn_rec_size_hi),
+      NULL },
+
+    { ngx_string("ssl_dyn_rec_threshold"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_num_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, dyn_rec_threshold),
+      NULL },
+#endif
+
       ngx_null_command
 };
 
@@ -399,6 +436,17 @@ static ngx_http_variable_t  ngx_http_ssl_vars[] = {
     { ngx_string("ssl_client_v_remain"), NULL, ngx_http_ssl_variable,
       (uintptr_t) ngx_ssl_get_client_v_remain, NGX_HTTP_VAR_CHANGEABLE, 0 },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("ssl_handshake_time"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_handshake_time, NGX_HTTP_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_handshake_start_ts"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_handshake_start_ts, NGX_HTTP_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_handshake_end_ts"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_handshake_end_ts, NGX_HTTP_VAR_CHANGEABLE, 0 },
+#endif
+
       ngx_http_null_variable
 };
 
@@ -629,6 +677,13 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)
     sscf->ocsp_cache_zone = NGX_CONF_UNSET_PTR;
     sscf->stapling = NGX_CONF_UNSET;
     sscf->stapling_verify = NGX_CONF_UNSET;
+#if (NGX_HTTP_EXT)
+    sscf->dyn_rec_enable = NGX_CONF_UNSET;
+    sscf->dyn_rec_timeout = NGX_CONF_UNSET_MSEC;
+    sscf->dyn_rec_size_lo = NGX_CONF_UNSET_SIZE;
+    sscf->dyn_rec_size_hi = NGX_CONF_UNSET_SIZE;
+    sscf->dyn_rec_threshold = NGX_CONF_UNSET_UINT;
+#endif
 
     return sscf;
 }
@@ -694,6 +749,22 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_str_value(conf->stapling_responder,
                          prev->stapling_responder, "");
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_value(conf->dyn_rec_enable, prev->dyn_rec_enable, 0);
+    ngx_conf_merge_msec_value(conf->dyn_rec_timeout, prev->dyn_rec_timeout,
+                             1000);
+    /* Default sizes for the dynamic record sizes are defined to fit maximal
+       TLS + IPv6 overhead in a single TCP segment for lo and 3 segments for hi:
+       1369 = 1500 - 40 (IP) - 20 (TCP) - 10 (Time) - 61 (Max TLS overhead) */
+    ngx_conf_merge_size_value(conf->dyn_rec_size_lo, prev->dyn_rec_size_lo,
+                             1369);
+    /* 4229 = (1500 - 40 - 20 - 10) * 3  - 61 */
+    ngx_conf_merge_size_value(conf->dyn_rec_size_hi, prev->dyn_rec_size_hi,
+                             4229);
+    ngx_conf_merge_uint_value(conf->dyn_rec_threshold, prev->dyn_rec_threshold,
+                             40);
+#endif
+
     conf->ssl.log = cf->log;
 
     if (conf->certificates) {
@@ -890,6 +961,30 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
         return NGX_CONF_ERROR;
     }
 
+#if (NGX_HTTP_EXT)
+    if (conf->dyn_rec_enable) {
+        conf->ssl.dyn_rec.timeout = conf->dyn_rec_timeout;
+        conf->ssl.dyn_rec.threshold = conf->dyn_rec_threshold;
+
+        if (conf->buffer_size > conf->dyn_rec_size_lo) {
+            conf->ssl.dyn_rec.size_lo = conf->dyn_rec_size_lo;
+
+        } else {
+            conf->ssl.dyn_rec.size_lo = conf->buffer_size;
+        }
+
+        if (conf->buffer_size > conf->dyn_rec_size_hi) {
+            conf->ssl.dyn_rec.size_hi = conf->dyn_rec_size_hi;
+
+        } else {
+            conf->ssl.dyn_rec.size_hi = conf->buffer_size;
+        }
+
+    } else {
+        conf->ssl.dyn_rec.timeout = 0;
+    }
+#endif
+
     return NGX_CONF_OK;
 }
 
diff --git a/src/http/modules/ngx_http_ssl_module.h b/src/http/modules/ngx_http_ssl_module.h
index c69c8ff..787e170 100644
--- a/src/http/modules/ngx_http_ssl_module.h
+++ b/src/http/modules/ngx_http_ssl_module.h
@@ -62,6 +62,14 @@ typedef struct {
     ngx_flag_t                      stapling_verify;
     ngx_str_t                       stapling_file;
     ngx_str_t                       stapling_responder;
+
+#if (NGX_HTTP_EXT)
+    ngx_flag_t                      dyn_rec_enable;
+    ngx_msec_t                      dyn_rec_timeout;
+    size_t                          dyn_rec_size_lo;
+    size_t                          dyn_rec_size_hi;
+    ngx_uint_t                      dyn_rec_threshold;
+#endif
 } ngx_http_ssl_srv_conf_t;
 
 
diff --git a/src/http/modules/ngx_http_sub_filter_module.c b/src/http/modules/ngx_http_sub_filter_module.c
index 456bb27..ae49243 100644
--- a/src/http/modules/ngx_http_sub_filter_module.c
+++ b/src/http/modules/ngx_http_sub_filter_module.c
@@ -43,6 +43,10 @@ typedef struct {
     ngx_flag_t                 once;
     ngx_flag_t                 last_modified;
 
+#if (NGX_HTTP_EXT)
+    ngx_array_t               *bypass;
+#endif
+
     ngx_array_t               *types_keys;
     ngx_array_t               *matches;
 } ngx_http_sub_loc_conf_t;
@@ -107,6 +111,15 @@ static ngx_command_t  ngx_http_sub_filter_commands[] = {
       0,
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("sub_filter_bypass"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_http_set_predicate_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_sub_loc_conf_t, bypass),
+      NULL },
+#endif
+
     { ngx_string("sub_filter_types"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
       ngx_http_types_slot,
@@ -186,6 +199,20 @@ ngx_http_sub_header_filter(ngx_http_request_t *r)
         return ngx_http_next_header_filter(r);
     }
 
+#if (NGX_HTTP_EXT)
+    switch (ngx_http_test_predicates(r, slcf->bypass)) {
+
+    case NGX_ERROR:
+        return NGX_ERROR;
+
+    case NGX_DECLINED:
+        return ngx_http_next_header_filter(r);
+
+    default: /* NGX_OK */
+        break;
+    }
+#endif
+
     ctx = ngx_pcalloc(r->pool, sizeof(ngx_http_sub_ctx_t));
     if (ctx == NULL) {
         return NGX_ERROR;
@@ -882,6 +909,10 @@ ngx_http_sub_create_conf(ngx_conf_t *cf)
     slcf->once = NGX_CONF_UNSET;
     slcf->last_modified = NGX_CONF_UNSET;
 
+#if (NGX_HTTP_EXT)
+    slcf->bypass = NGX_CONF_UNSET_PTR;
+#endif
+
     return slcf;
 }
 
@@ -898,6 +929,10 @@ ngx_http_sub_merge_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_value(conf->once, prev->once, 1);
     ngx_conf_merge_value(conf->last_modified, prev->last_modified, 0);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_ptr_value(conf->bypass, prev->bypass, NULL);
+#endif
+
     if (ngx_http_merge_types(cf, &conf->types_keys, &conf->types,
                              &prev->types_keys, &prev->types,
                              ngx_http_html_default_types)
diff --git a/src/http/modules/ngx_http_uwsgi_module.c b/src/http/modules/ngx_http_uwsgi_module.c
index c965d4b..c51df4e 100644
--- a/src/http/modules/ngx_http_uwsgi_module.c
+++ b/src/http/modules/ngx_http_uwsgi_module.c
@@ -42,6 +42,11 @@ typedef struct {
     ngx_http_complex_value_t   cache_key;
 #endif
 
+#if (NGX_HTTP_EXT)
+    size_t                     sndbuf;
+    size_t                     rcvbuf;
+#endif
+
     ngx_str_t                  uwsgi_string;
 
     ngx_uint_t                 modifier1;
@@ -331,6 +336,15 @@ static ngx_command_t ngx_http_uwsgi_commands[] = {
       offsetof(ngx_http_uwsgi_loc_conf_t, upstream.no_cache),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("uwsgi_cache_types"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_http_types_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_uwsgi_loc_conf_t, upstream.cache_types_keys),
+      &ngx_http_html_default_types[0] },
+#endif
+
     { ngx_string("uwsgi_cache_valid"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
       ngx_http_file_cache_valid_set_slot,
@@ -338,6 +352,15 @@ static ngx_command_t ngx_http_uwsgi_commands[] = {
       offsetof(ngx_http_uwsgi_loc_conf_t, upstream.cache_valid),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("uwsgi_cache_min_age"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_http_set_complex_value_sec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_uwsgi_loc_conf_t, upstream.cache_min_age),
+      NULL },
+#endif
+
     { ngx_string("uwsgi_cache_min_uses"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_num_slot,
@@ -359,6 +382,23 @@ static ngx_command_t ngx_http_uwsgi_commands[] = {
       offsetof(ngx_http_uwsgi_loc_conf_t, upstream.cache_use_stale),
       &ngx_http_uwsgi_next_upstream_masks },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("uwsgi_cache_stale_if_error"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_set_complex_value_sec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_uwsgi_loc_conf_t, upstream.cache_stale_if_error),
+      NULL },
+
+    { ngx_string("uwsgi_cache_stale_while_revalidate"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_set_complex_value_sec_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_uwsgi_loc_conf_t,
+                upstream.cache_stale_while_revalidate),
+      NULL },
+#endif
+
     { ngx_string("uwsgi_cache_methods"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
       ngx_conf_set_bitmask_slot,
@@ -480,6 +520,29 @@ static ngx_command_t ngx_http_uwsgi_commands[] = {
       offsetof(ngx_http_uwsgi_loc_conf_t, upstream.ignore_headers),
       &ngx_http_upstream_ignore_headers_masks },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("uwsgi_ignore_cache_control"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
+      ngx_conf_set_bitmask_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_uwsgi_loc_conf_t, upstream.ignore_cache_control),
+      &ngx_http_upstream_ignore_cache_control_masks },
+
+    { ngx_string("uwsgi_sndbuf_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_uwsgi_loc_conf_t, sndbuf),
+      NULL },
+
+    { ngx_string("uwsgi_rcvbuf_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_uwsgi_loc_conf_t, rcvbuf),
+      NULL },
+#endif
+
 #if (NGX_HTTP_SSL)
 
     { ngx_string("uwsgi_ssl_session_reuse"),
@@ -708,6 +771,16 @@ ngx_http_uwsgi_handler(ngx_http_request_t *r)
 
     u->buffering = uwcf->upstream.buffering;
 
+#if (NGX_HTTP_EXT)
+    if (uwcf->sndbuf > 0) {
+        u->peer.sndbuf = uwcf->sndbuf;
+    }
+
+    if (uwcf->rcvbuf > 0) {
+        u->peer.rcvbuf = uwcf->rcvbuf;
+    }
+#endif
+
     u->pipe = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t));
     if (u->pipe == NULL) {
         return NGX_HTTP_INTERNAL_SERVER_ERROR;
@@ -1543,7 +1616,14 @@ ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf)
 
 #if (NGX_HTTP_CACHE)
     conf->upstream.cache = NGX_CONF_UNSET;
+#if (NGX_HTTP_EXT)
+    conf->upstream.cache_min_age = NGX_CONF_UNSET_PTR;
+#endif
     conf->upstream.cache_min_uses = NGX_CONF_UNSET_UINT;
+#if (NGX_HTTP_EXT)
+    conf->upstream.cache_stale_if_error = NGX_CONF_UNSET_PTR;
+    conf->upstream.cache_stale_while_revalidate = NGX_CONF_UNSET_PTR;
+#endif
     conf->upstream.cache_max_range_offset = NGX_CONF_UNSET;
     conf->upstream.cache_bypass = NGX_CONF_UNSET_PTR;
     conf->upstream.no_cache = NGX_CONF_UNSET_PTR;
@@ -1577,6 +1657,11 @@ ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf)
 
     conf->upstream.change_buffering = 1;
 
+#if (NGX_HTTP_EXT)
+    conf->sndbuf = NGX_CONF_UNSET_SIZE;
+    conf->rcvbuf = NGX_CONF_UNSET_SIZE;
+#endif
+
     ngx_str_set(&conf->upstream.module, "uwsgi");
 
     return conf;
@@ -1659,6 +1744,10 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_ptr_value(conf->upstream.limit_rate,
                               prev->upstream.limit_rate, NULL);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_size_value(conf->sndbuf, prev->sndbuf, (size_t) 0);
+    ngx_conf_merge_size_value(conf->rcvbuf, prev->rcvbuf, (size_t) 0);
+#endif
 
     ngx_conf_merge_bufs_value(conf->upstream.bufs, prev->upstream.bufs,
                               8, ngx_pagesize);
@@ -1756,6 +1845,11 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
                                  prev->upstream.ignore_headers,
                                  NGX_CONF_BITMASK_SET);
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_bitmask_value(conf->upstream.ignore_cache_control,
+                              prev->upstream.ignore_cache_control,
+                              NGX_CONF_BITMASK_SET);
+#endif
 
     ngx_conf_merge_bitmask_value(conf->upstream.next_upstream,
                                  prev->upstream.next_upstream,
@@ -1798,6 +1892,11 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
         return NGX_CONF_ERROR;
     }
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_ptr_value(conf->upstream.cache_min_age,
+                              prev->upstream.cache_min_age, NULL);
+#endif
+
     ngx_conf_merge_uint_value(conf->upstream.cache_min_uses,
                               prev->upstream.cache_min_uses, 1);
 
@@ -1819,6 +1918,15 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
         conf->upstream.cache_use_stale |= NGX_HTTP_UPSTREAM_FT_NOLIVE;
     }
 
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_ptr_value(conf->upstream.cache_stale_if_error,
+                              prev->upstream.cache_stale_if_error,
+                              NULL);
+    ngx_conf_merge_ptr_value(conf->upstream.cache_stale_while_revalidate,
+                              prev->upstream.cache_stale_while_revalidate,
+                              NULL);
+#endif
+
     if (conf->upstream.cache_methods == 0) {
         conf->upstream.cache_methods = prev->upstream.cache_methods;
     }
@@ -1831,6 +1939,18 @@ ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_ptr_value(conf->upstream.no_cache,
                              prev->upstream.no_cache, NULL);
 
+#if (NGX_HTTP_EXT)
+    if (ngx_http_merge_types(cf, &conf->upstream.cache_types_keys,
+                             &conf->upstream.cache_types,
+                             &prev->upstream.cache_types_keys,
+                             &prev->upstream.cache_types,
+                             ngx_http_html_default_types)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+#endif
+
     ngx_conf_merge_ptr_value(conf->upstream.cache_valid,
                              prev->upstream.cache_valid, NULL);
 
diff --git a/src/http/ngx_http.c b/src/http/ngx_http.c
index d835f89..1b06ef5 100644
--- a/src/http/ngx_http.c
+++ b/src/http/ngx_http.c
@@ -1237,6 +1237,9 @@ ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
     ngx_http_conf_addr_t  *addr;
 #if (NGX_HTTP_SSL)
     ngx_uint_t             ssl;
+#if (NGX_HTTP_EXT)
+    ngx_uint_t             https_allow_http;
+#endif
 #endif
 #if (NGX_HTTP_V2)
     ngx_uint_t             http2;
@@ -1279,6 +1282,9 @@ ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
         ssl = lsopt->ssl || addr[i].opt.ssl;
         protocols |= lsopt->ssl << 1;
         protocols_prev |= addr[i].opt.ssl << 1;
+#if (NGX_HTTP_EXT)
+        https_allow_http = lsopt->https_allow_http || addr[i].opt.https_allow_http;
+#endif
 #endif
 #if (NGX_HTTP_V2)
         http2 = lsopt->http2 || addr[i].opt.http2;
@@ -1371,6 +1377,9 @@ ngx_http_add_addresses(ngx_conf_t *cf, ngx_http_core_srv_conf_t *cscf,
         addr[i].opt.proxy_protocol = proxy_protocol;
 #if (NGX_HTTP_SSL)
         addr[i].opt.ssl = ssl;
+#if (NGX_HTTP_EXT)
+        addr[i].opt.https_allow_http = https_allow_http;
+#endif
 #endif
 #if (NGX_HTTP_V2)
         addr[i].opt.http2 = http2;
@@ -1914,6 +1923,9 @@ ngx_http_add_addrs(ngx_conf_t *cf, ngx_http_port_t *hport,
         addrs[i].conf.default_server = addr[i].default_server;
 #if (NGX_HTTP_SSL)
         addrs[i].conf.ssl = addr[i].opt.ssl;
+#if (NGX_HTTP_EXT)
+        addrs[i].conf.https_allow_http = addr[i].opt.https_allow_http;
+#endif
 #endif
 #if (NGX_HTTP_V2)
         addrs[i].conf.http2 = addr[i].opt.http2;
@@ -1982,6 +1994,9 @@ ngx_http_add_addrs6(ngx_conf_t *cf, ngx_http_port_t *hport,
         addrs6[i].conf.default_server = addr[i].default_server;
 #if (NGX_HTTP_SSL)
         addrs6[i].conf.ssl = addr[i].opt.ssl;
+#if (NGX_HTTP_EXT)
+        addrs6[i].conf.https_allow_http = addr[i].opt.https_allow_http;
+#endif
 #endif
 #if (NGX_HTTP_V2)
         addrs6[i].conf.http2 = addr[i].opt.http2;
diff --git a/src/http/ngx_http_cache.h b/src/http/ngx_http_cache.h
index bb936c5..2b194c5 100644
--- a/src/http/ngx_http_cache.h
+++ b/src/http/ngx_http_cache.h
@@ -32,7 +32,11 @@
 
 typedef struct {
     ngx_uint_t                       status;
+#if (NGX_HTTP_EXT)
+    ngx_http_complex_value_t        *valid;
+#else
     time_t                           valid;
+#endif
 } ngx_http_cache_valid_t;
 
 
@@ -196,7 +200,12 @@ void ngx_http_file_cache_update(ngx_http_request_t *r, ngx_temp_file_t *tf);
 void ngx_http_file_cache_update_header(ngx_http_request_t *r);
 ngx_int_t ngx_http_cache_send(ngx_http_request_t *);
 void ngx_http_file_cache_free(ngx_http_cache_t *c, ngx_temp_file_t *tf);
+#if (NGX_HTTP_EXT)
+time_t ngx_http_file_cache_valid(ngx_http_request_t *r,
+    ngx_array_t *cache_valid, ngx_uint_t status);
+#else
 time_t ngx_http_file_cache_valid(ngx_array_t *cache_valid, ngx_uint_t status);
+#endif
 
 char *ngx_http_file_cache_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c
index 937ffe2..89dfa8d 100644
--- a/src/http/ngx_http_core_module.c
+++ b/src/http/ngx_http_core_module.c
@@ -745,6 +745,29 @@ static ngx_command_t  ngx_http_core_commands[] = {
       offsetof(ngx_http_core_loc_conf_t, resolver_timeout),
       NULL },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("error_page_server_info"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_core_loc_conf_t, error_page_server_info),
+      NULL },
+
+    { ngx_string("error_page_client_ip"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_set_complex_value_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_core_loc_conf_t, error_page_client_ip),
+      NULL },
+
+    { ngx_string("error_page_request_id"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_http_set_complex_value_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_core_loc_conf_t, error_page_request_id),
+      NULL },
+#endif
+
 #if (NGX_HTTP_GZIP)
 
     { ngx_string("gzip_vary"),
@@ -3642,6 +3665,11 @@ ngx_http_core_create_loc_conf(ngx_conf_t *cf)
     clcf->open_file_cache_errors = NGX_CONF_UNSET;
     clcf->open_file_cache_events = NGX_CONF_UNSET;
 
+#if (NGX_HTTP_EXT)
+    clcf->error_page_server_info = NGX_CONF_UNSET;
+    clcf->error_page_client_ip = NGX_CONF_UNSET_PTR;
+    clcf->error_page_request_id = NGX_CONF_UNSET_PTR;
+#endif
 #if (NGX_HTTP_GZIP)
     clcf->gzip_vary = NGX_CONF_UNSET;
     clcf->gzip_http_version = NGX_CONF_UNSET_UINT;
@@ -3923,6 +3951,15 @@ ngx_http_core_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)
 
     ngx_conf_merge_sec_value(conf->open_file_cache_events,
                               prev->open_file_cache_events, 0);
+
+#if (NGX_HTTP_EXT)
+    ngx_conf_merge_value(conf->error_page_server_info, prev->error_page_server_info, 1);
+    ngx_conf_merge_ptr_value(conf->error_page_client_ip,
+                             prev->error_page_client_ip, NULL);
+    ngx_conf_merge_ptr_value(conf->error_page_request_id,
+                             prev->error_page_request_id, NULL);
+#endif
+
 #if (NGX_HTTP_GZIP)
 
     ngx_conf_merge_value(conf->gzip_vary, prev->gzip_vary, 0);
@@ -4312,6 +4349,18 @@ ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
             continue;
         }
 
+#if (NGX_HTTP_EXT && NGX_HTTP_SSL)
+        if (ngx_strcmp(value[n].data, "https_allow_http") == 0) {
+            lsopt.https_allow_http = 1;
+            continue;
+
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "the \"https_allow_http\" parameter requires "
+                               "ngx_http_ssl_module");
+            return NGX_CONF_ERROR;
+        }
+#endif
+
         ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                            "invalid parameter \"%V\"", &value[n]);
         return NGX_CONF_ERROR;
diff --git a/src/http/ngx_http_core_module.h b/src/http/ngx_http_core_module.h
index 765e7ff..f9fc0a6 100644
--- a/src/http/ngx_http_core_module.h
+++ b/src/http/ngx_http_core_module.h
@@ -83,6 +83,9 @@ typedef struct {
     unsigned                   reuseport:1;
     unsigned                   so_keepalive:2;
     unsigned                   proxy_protocol:1;
+#if (NGX_HTTP_EXT && NGX_HTTP_SSL)
+    unsigned                   https_allow_http:1;
+#endif
 
     int                        backlog;
     int                        rcvbuf;
@@ -241,6 +244,9 @@ struct ngx_http_addr_conf_s {
     unsigned                   http2:1;
     unsigned                   quic:1;
     unsigned                   proxy_protocol:1;
+#if (NGX_HTTP_EXT && NGX_HTTP_SSL)
+    unsigned                   https_allow_http:1;
+#endif
 };
 
 
@@ -446,6 +452,13 @@ struct ngx_http_core_loc_conf_s {
 
     ngx_queue_t  *locations;
 
+#if (NGX_HTTP_EXT)
+    ngx_flag_t    error_page_server_info;  /* error_page_server_info */
+
+    ngx_http_complex_value_t *error_page_client_ip; /* error_page_client_ip */
+    ngx_http_complex_value_t *error_page_request_id; /* error_page_request_id */
+#endif
+
 #if 0
     ngx_http_core_loc_conf_t  *prev_location;
 #endif
diff --git a/src/http/ngx_http_file_cache.c b/src/http/ngx_http_file_cache.c
index 5209f00..d0b4515 100644
--- a/src/http/ngx_http_file_cache.c
+++ b/src/http/ngx_http_file_cache.c
@@ -2349,8 +2349,14 @@ ngx_http_file_cache_set_watermark(ngx_http_file_cache_t *cache)
 }
 
 
+#if (NGX_HTTP_EXT)
+time_t
+ngx_http_file_cache_valid(ngx_http_request_t *r,
+    ngx_array_t *cache_valid, ngx_uint_t status)
+#else
 time_t
 ngx_http_file_cache_valid(ngx_array_t *cache_valid, ngx_uint_t status)
+#endif
 {
     ngx_uint_t               i;
     ngx_http_cache_valid_t  *valid;
@@ -2362,6 +2368,29 @@ ngx_http_file_cache_valid(ngx_array_t *cache_valid, ngx_uint_t status)
     valid = cache_valid->elts;
     for (i = 0; i < cache_valid->nelts; i++) {
 
+#if (NGX_HTTP_EXT)
+        ngx_str_t            unparsed_valid_time;
+        time_t               valid_time;
+
+        if (valid[i].status == 0 || valid[i].status == status) {
+
+            if (ngx_http_complex_value(r, valid[i].valid,&unparsed_valid_time)
+                != NGX_OK) {
+                return 0;
+            }
+
+            valid_time = ngx_parse_time(&unparsed_valid_time, 1);
+
+            if (valid_time == (time_t) NGX_ERROR) {
+                ngx_log_error(NGX_LOG_EMERG, r->connection->log, 0,
+                              "invalid time value \"%V\"",
+                              &unparsed_valid_time);
+                return 0;
+            }
+
+            return valid_time;
+        }
+#else
         if (valid[i].status == 0) {
             return valid[i].valid;
         }
@@ -2369,6 +2398,7 @@ ngx_http_file_cache_valid(ngx_array_t *cache_valid, ngx_uint_t status)
         if (valid[i].status == status) {
             return valid[i].valid;
         }
+#endif
     }
 
     return 0;
@@ -2728,6 +2758,16 @@ ngx_http_file_cache_valid_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
 {
     char  *p = conf;
 
+#if (NGX_HTTP_EXT)
+    ngx_str_t                         *value;
+    ngx_int_t                          status;
+    ngx_uint_t                         i, n;
+    ngx_array_t                      **a;
+    ngx_http_cache_valid_t            *v;
+    static ngx_uint_t                  statuses[] = { 200, 301, 302 };
+    ngx_http_complex_value_t          *valid_cv;
+    ngx_http_compile_complex_value_t   valid_ccv;
+#else
     time_t                    valid;
     ngx_str_t                *value;
     ngx_int_t                 status;
@@ -2735,6 +2775,7 @@ ngx_http_file_cache_valid_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
     ngx_array_t             **a;
     ngx_http_cache_valid_t   *v;
     static ngx_uint_t         statuses[] = { 200, 301, 302 };
+#endif
 
     a = (ngx_array_t **) (p + cmd->offset);
 
@@ -2748,12 +2789,24 @@ ngx_http_file_cache_valid_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
     value = cf->args->elts;
     n = cf->args->nelts - 1;
 
+#if (NGX_HTTP_EXT)
+    valid_cv = malloc(sizeof(ngx_http_complex_value_t));
+    ngx_memzero(&valid_ccv, sizeof(ngx_http_compile_complex_value_t));
+    valid_ccv.cf = cf;
+    valid_ccv.value = &value[n];
+    valid_ccv.complex_value = valid_cv;
+
+    if (ngx_http_compile_complex_value(&valid_ccv) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+#else
     valid = ngx_parse_time(&value[n], 1);
     if (valid == (time_t) NGX_ERROR) {
         ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                            "invalid time value \"%V\"", &value[n]);
         return NGX_CONF_ERROR;
     }
+#endif
 
     if (n == 1) {
 
@@ -2764,7 +2817,11 @@ ngx_http_file_cache_valid_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
             }
 
             v->status = statuses[i];
+#if (NGX_HTTP_EXT)
+            v->valid = valid_cv;
+#else
             v->valid = valid;
+#endif
         }
 
         return NGX_CONF_OK;
@@ -2792,7 +2849,11 @@ ngx_http_file_cache_valid_set_slot(ngx_conf_t *cf, ngx_command_t *cmd,
         }
 
         v->status = status;
+#if (NGX_HTTP_EXT)
+        v->valid = valid_cv;
+#else
         v->valid = valid;
+#endif
     }
 
     return NGX_CONF_OK;
diff --git a/src/http/ngx_http_header_filter_module.c b/src/http/ngx_http_header_filter_module.c
index 90525ef..fd64777 100644
--- a/src/http/ngx_http_header_filter_module.c
+++ b/src/http/ngx_http_header_filter_module.c
@@ -167,6 +167,9 @@ ngx_http_header_filter(ngx_http_request_t *r)
     ngx_connection_t          *c;
     ngx_http_core_loc_conf_t  *clcf;
     ngx_http_core_srv_conf_t  *cscf;
+#if (NGX_HTTP_EXT)
+    ngx_time_t                *tp;
+#endif
     u_char                     addr[NGX_SOCKADDR_STRLEN];
 
     if (r->header_sent) {
@@ -175,6 +178,12 @@ ngx_http_header_filter(ngx_http_request_t *r)
 
     r->header_sent = 1;
 
+#if (NGX_HTTP_EXT)
+    tp = ngx_timeofday();
+    r->header_sent_sec = tp->sec;
+    r->header_sent_msec = tp->msec;
+#endif
+
     if (r != r->main) {
         return NGX_OK;
     }
diff --git a/src/http/ngx_http_request.c b/src/http/ngx_http_request.c
index 3cca57c..9c8ed7b 100644
--- a/src/http/ngx_http_request.c
+++ b/src/http/ngx_http_request.c
@@ -668,6 +668,9 @@ ngx_http_ssl_handshake(ngx_event_t *rev)
     ssize_t                    n;
     ngx_err_t                  err;
     ngx_int_t                  rc;
+#if (NGX_HTTP_EXT)
+    ngx_time_t                *tp;
+#endif
     ngx_connection_t          *c;
     ngx_http_connection_t     *hc;
     ngx_http_ssl_srv_conf_t   *sscf;
@@ -774,6 +777,11 @@ ngx_http_ssl_handshake(ngx_event_t *rev)
                 return;
             }
 
+#if (NGX_HTTP_EXT)
+            tp = ngx_timeofday();
+            c->ssl->handshake_start_msec = tp->sec * 1000 + tp->msec;
+#endif
+
             ngx_reusable_connection(c, 0);
 
             rc = ngx_ssl_handshake(c);
@@ -799,6 +807,12 @@ ngx_http_ssl_handshake(ngx_event_t *rev)
 
         c->log->action = "waiting for request";
 
+#if (NGX_HTTP_EXT && NGX_HTTP_SSL)
+        if (hc->addr_conf->https_allow_http) {
+            hc->ssl = 0;
+        }
+#endif
+
         rev->handler = ngx_http_wait_request_handler;
         ngx_http_wait_request_handler(rev);
 
diff --git a/src/http/ngx_http_request.h b/src/http/ngx_http_request.h
index 65c8333..af56d1c 100644
--- a/src/http/ngx_http_request.h
+++ b/src/http/ngx_http_request.h
@@ -408,6 +408,11 @@ struct ngx_http_request_s {
     time_t                            start_sec;
     ngx_msec_t                        start_msec;
 
+#if (NGX_HTTP_EXT)
+    time_t                            header_sent_sec;
+    ngx_msec_t                        header_sent_msec;
+#endif
+
     ngx_uint_t                        method;
     ngx_uint_t                        http_version;
 
diff --git a/src/http/ngx_http_script.c b/src/http/ngx_http_script.c
index a2b9f1b..ac4a0ae 100644
--- a/src/http/ngx_http_script.c
+++ b/src/http/ngx_http_script.c
@@ -134,6 +134,68 @@ ngx_http_complex_value_size(ngx_http_request_t *r,
     return size;
 }
 
+#if (NGX_HTTP_EXT)
+ngx_msec_t
+ngx_http_complex_value_msec(ngx_http_request_t *r,
+    ngx_http_complex_value_t *val, ngx_msec_t default_value)
+{
+    ngx_msec_t  msec;
+    ngx_str_t   value;
+
+    if (val == NULL) {
+        return default_value;
+    }
+
+    if (val->lengths == NULL) {
+        return val->u.msec;
+    }
+
+    if (ngx_http_complex_value(r, val, &value) != NGX_OK) {
+        return default_value;
+    }
+
+    msec = ngx_parse_time(&value, 0);
+
+    if (msec == (ngx_msec_t) NGX_ERROR) {
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                      "invalid msec \"%V\"", &value);
+        return default_value;
+    }
+
+    return msec;
+}
+
+
+time_t
+ngx_http_complex_value_sec(ngx_http_request_t *r,
+    ngx_http_complex_value_t *val, time_t default_value)
+{
+    time_t     sec;
+    ngx_str_t  value;
+
+    if (val == NULL) {
+        return default_value;
+    }
+
+    if (val->lengths == NULL) {
+        return val->u.sec;
+    }
+
+    if (ngx_http_complex_value(r, val, &value) != NGX_OK) {
+        return default_value;
+    }
+
+    sec = ngx_parse_time(&value, 1);
+
+    if (sec == (time_t) NGX_ERROR) {
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                      "invalid sec \"%V\"", &value);
+        return default_value;
+    }
+
+    return sec;
+}
+#endif
 
 ngx_int_t
 ngx_http_compile_complex_value(ngx_http_compile_complex_value_t *ccv)
@@ -343,6 +405,67 @@ ngx_http_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,
 }
 
 
+#if (NGX_HTTP_EXT)
+char *
+ngx_http_set_complex_value_msec_slot(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf)
+{
+    char  *p = conf;
+
+    char                      *rv;
+    ngx_http_complex_value_t  *cv;
+
+    rv = ngx_http_set_complex_value_slot(cf, cmd, conf);
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    cv = *(ngx_http_complex_value_t **) (p + cmd->offset);
+
+    if (cv->lengths) {
+        return NGX_CONF_OK;
+    }
+
+    cv->u.msec = ngx_parse_time(&cv->value, 1);
+    if (cv->u.msec == (ngx_msec_t) NGX_ERROR) {
+        return "invalid value";
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+char *
+ngx_http_set_complex_value_sec_slot(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf)
+{
+    char  *p = conf;
+
+    char                      *rv;
+    ngx_http_complex_value_t  *cv;
+
+    rv = ngx_http_set_complex_value_slot(cf, cmd, conf);
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    cv = *(ngx_http_complex_value_t **) (p + cmd->offset);
+
+    if (cv->lengths) {
+        return NGX_CONF_OK;
+    }
+
+    cv->u.sec = ngx_parse_time(&cv->value, 1);
+    if (cv->u.sec == (time_t) NGX_ERROR) {
+        return "invalid value";
+    }
+
+    return NGX_CONF_OK;
+}
+#endif
+
 ngx_int_t
 ngx_http_test_predicates(ngx_http_request_t *r, ngx_array_t *predicates)
 {
@@ -1534,6 +1657,10 @@ ngx_http_script_if_code(ngx_http_script_engine_t *e)
 
     e->sp--;
 
+#if (NGX_HTTP_EXT)
+    e->if_matched = 0;
+#endif
+
     if (e->sp->len && (e->sp->len != 1 || e->sp->data[0] != '0')) {
         if (code->loc_conf) {
             e->request->loc_conf = code->loc_conf;
@@ -1541,6 +1668,9 @@ ngx_http_script_if_code(ngx_http_script_engine_t *e)
         }
 
         e->ip += sizeof(ngx_http_script_if_code_t);
+#if (NGX_HTTP_EXT)
+        e->if_matched = 1;
+#endif
         return;
     }
 
@@ -1551,6 +1681,68 @@ ngx_http_script_if_code(ngx_http_script_engine_t *e)
 }
 
 
+#if (NGX_HTTP_EXT)
+void
+ngx_http_script_elif_code(ngx_http_script_engine_t *e)
+{
+    ngx_http_script_if_code_t  *code;
+
+    code = (ngx_http_script_if_code_t *) e->ip;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script elif");
+
+    e->sp--;
+
+    if (e->if_matched != 1 && e->sp->len
+        && (e->sp->len != 1 || e->sp->data[0] != '0')) 
+    {
+        if (code->loc_conf) {
+            e->request->loc_conf = code->loc_conf;
+            ngx_http_update_location_config(e->request);
+        }
+
+        e->ip += sizeof(ngx_http_script_if_code_t);
+        e->if_matched = 1;
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script elif: false");
+
+    e->ip += code->next;
+}
+
+
+void
+ngx_http_script_else_code(ngx_http_script_engine_t *e)
+{
+    ngx_http_script_if_code_t  *code;
+
+    code = (ngx_http_script_if_code_t *) e->ip;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script else");
+
+    if (e->if_matched != 1) {
+        if (code->loc_conf) {
+            e->request->loc_conf = code->loc_conf;
+            ngx_http_update_location_config(e->request);
+        }
+
+        e->ip += sizeof(ngx_http_script_if_code_t);
+        e->if_matched = 1;
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script else: false");
+
+    e->ip += code->next;
+}
+#endif
+
+
 void
 ngx_http_script_equal_code(ngx_http_script_engine_t *e)
 {
@@ -1898,3 +2090,332 @@ ngx_http_script_nop_code(ngx_http_script_engine_t *e)
 {
     e->ip += sizeof(uintptr_t);
 }
+
+
+#if (NGX_HTTP_EXT)
+void
+ngx_http_script_if_operator_code(ngx_http_script_engine_t *e)
+{
+    ngx_http_script_if_operator_code_t *code;
+    ngx_uint_t                          op;
+    ngx_http_variable_value_t          *val, *res;
+
+    code = (ngx_http_script_if_operator_code_t *) e->ip;
+    op = code->op;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script if operator %u", op);
+
+    e->sp--;
+    val = e->sp;
+    res = val;
+    res = e->sp - 1;
+
+    if (op == ngx_http_script_if_and) {
+        if ((val->len && (val->len != 1 || val->data[0] != '0'))
+            && (res->len && (res->len != 1 || res->data[0] != '0'))) {
+            *res = ngx_http_variable_true_value;
+        } else {
+            *res = ngx_http_variable_null_value;
+        }
+
+    } else if (op == ngx_http_script_if_or) {
+        if ((val->len && (val->len != 1 || val->data[0] != '0'))
+            || (res->len && (res->len != 1 || res->data[0] != '0'))) {
+            *res = ngx_http_variable_true_value;
+        } else {
+            *res = ngx_http_variable_null_value;
+        }
+
+    } else {
+        ngx_log_error(NGX_LOG_ERR, e->request->connection->log, 0,
+                "the operator %u isn't supported", op);
+    }
+
+    e->ip += sizeof(ngx_http_script_if_operator_code_t);
+
+    return;
+}
+
+
+ngx_int_t
+ngx_http_script_auto_atofp(u_char *data1, size_t len1, u_char *data2, size_t len2,
+    ngx_int_t *val1, ngx_int_t *val2)
+{
+    ngx_uint_t decimal_places1 = 0, decimal_places2 = 0;
+    ngx_int_t  is_negative1 = 0, is_negative2 = 0;
+
+    if (len1 > 0 && data1[0] == '-') {
+        is_negative1 = 1;
+        data1++;
+        len1--;
+    }
+
+    if (len2 > 0 && data2[0] == '-') {
+        is_negative2 = 1;
+        data2++;
+        len2--;
+    }
+
+    for (ngx_uint_t i = 0; i < len1; i++) {
+        if (data1[i] == '.') {
+            decimal_places1 = len1 - i - 1;
+            break;
+        }
+    }
+
+    for (ngx_uint_t i = 0; i < len2; i++) {
+        if (data2[i] == '.') {
+            decimal_places2 = len2 - i - 1;
+            break;
+        }
+    }
+
+    ngx_uint_t max_decimal_places = (decimal_places1 > decimal_places2)
+        ? decimal_places1 : decimal_places2;
+
+    if (max_decimal_places == 0) {
+        *val1 = ngx_atoi(data1, len1);
+        *val2 = ngx_atoi(data2, len2);
+    } else {
+        *val1 = ngx_atofp(data1, len1, max_decimal_places);
+        *val2 = ngx_atofp(data2, len2, max_decimal_places);
+    }
+
+    if (*val1 == NGX_ERROR || *val2 == NGX_ERROR) {
+        return NGX_ERROR;
+    }
+
+    if (is_negative1 == 1) {
+        *val1 = -*val1;
+    }
+
+    if (is_negative2 == 1) {
+        *val2 = -*val2;
+    }
+
+    return NGX_OK;
+}
+
+
+void
+ngx_http_script_greater_than_code(ngx_http_script_engine_t *e)
+{
+    ngx_http_variable_value_t  *val, *res;
+    ngx_int_t                   int_val, int_res;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script greater than");
+
+    e->sp--;
+    val = e->sp;
+    res = e->sp - 1;
+
+    e->ip += sizeof(uintptr_t);
+
+    if (ngx_http_script_auto_atofp(res->data, res->len, val->data, val->len,
+                                &int_res, &int_val) != NGX_OK)
+    {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                       "http script greater than: error in auto atofp conversion");
+        *res = ngx_http_variable_null_value;
+        return;
+    }
+
+    if (int_res > int_val) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                       "http script greater than: yes");
+        *res = ngx_http_variable_true_value;
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script greater than: no");
+
+    *res = ngx_http_variable_null_value;
+}
+
+
+void
+ngx_http_script_greater_equal_code(ngx_http_script_engine_t *e)
+{
+    ngx_http_variable_value_t  *val, *res;
+    ngx_int_t                   int_val, int_res;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script greater equal");
+
+    e->sp--;
+    val = e->sp;
+    res = e->sp - 1;
+
+    e->ip += sizeof(uintptr_t);
+
+    if (ngx_http_script_auto_atofp(res->data, res->len, val->data, val->len,
+                                &int_res, &int_val) != NGX_OK)
+    {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                       "http script greater equal: error in auto atofp conversion");
+        *res = ngx_http_variable_null_value;
+        return;
+    }
+
+    if (int_res >= int_val) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                       "http script greater equal: yes");
+        *res = ngx_http_variable_true_value;
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script greater equal: no");
+
+    *res = ngx_http_variable_null_value;
+}
+
+
+void
+ngx_http_script_less_than_code(ngx_http_script_engine_t *e)
+{
+    ngx_http_variable_value_t  *val, *res;
+    ngx_int_t                   int_val, int_res;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script less than");
+
+    e->sp--;
+    val = e->sp;
+    res = e->sp - 1;
+
+    e->ip += sizeof(uintptr_t);
+
+    if (ngx_http_script_auto_atofp(res->data, res->len, val->data, val->len,
+                                &int_res, &int_val) != NGX_OK)
+    {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                       "http script less than: error in auto atofp conversion");
+        *res = ngx_http_variable_null_value;
+        return;
+    }
+
+    if (int_res < int_val) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                       "http script less than: yes");
+        *res = ngx_http_variable_true_value;
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script less than: no");
+
+    *res = ngx_http_variable_null_value;
+}
+
+
+void
+ngx_http_script_less_equal_code(ngx_http_script_engine_t *e)
+{
+    ngx_http_variable_value_t  *val, *res;
+    ngx_int_t                   int_val, int_res;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script less equal");
+
+    e->sp--;
+    val = e->sp;
+    res = e->sp - 1;
+
+    e->ip += sizeof(uintptr_t);
+
+    if (ngx_http_script_auto_atofp(res->data, res->len, val->data, val->len,
+                                &int_res, &int_val) != NGX_OK)
+    {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                       "http script less equal: error in auto atofp conversion");
+        *res = ngx_http_variable_null_value;
+        return;
+    }
+
+    if (int_res <= int_val) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                       "http script less equal: yes");
+        *res = ngx_http_variable_true_value;
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script less equal: no");
+
+    *res = ngx_http_variable_null_value;
+}
+
+
+void
+ngx_http_script_start_with_code(ngx_http_script_engine_t *e)
+{
+    ngx_http_variable_value_t  *val, *res;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script start with");
+
+    e->sp--;
+    val = e->sp;
+    res = e->sp - 1;
+
+    e->ip += sizeof(uintptr_t);
+
+    if (res->len < val->len) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                       "http script start with: no");
+        *res = ngx_http_variable_null_value;
+        return;
+    }
+
+    if (ngx_strncmp(res->data, val->data, val->len) == 0) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                       "http script start with: yes");
+        *res = ngx_http_variable_true_value;
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script start with: no");
+
+    *res = ngx_http_variable_null_value;
+}
+
+
+void
+ngx_http_script_not_start_with_code(ngx_http_script_engine_t *e)
+{
+    ngx_http_variable_value_t  *val, *res;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http not script start with");
+
+    e->sp--;
+    val = e->sp;
+    res = e->sp - 1;
+
+    e->ip += sizeof(uintptr_t);
+
+    if (res->len < val->len) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                       "http not script start with: yes");
+        *res = ngx_http_variable_true_value;
+        return;
+    }
+
+    if (ngx_strncmp(res->data, val->data, val->len) == 0) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                       "http script start with: no");
+        *res = ngx_http_variable_null_value;
+        return;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, e->request->connection->log, 0,
+                   "http script start with: yes");
+
+    *res = ngx_http_variable_true_value;
+}
+#endif
\ No newline at end of file
diff --git a/src/http/ngx_http_script.h b/src/http/ngx_http_script.h
index 4360038..d02beea 100644
--- a/src/http/ngx_http_script.h
+++ b/src/http/ngx_http_script.h
@@ -33,6 +33,10 @@ typedef struct {
 
     ngx_int_t                   status;
     ngx_http_request_t         *request;
+
+#if (NGX_HTTP_EXT)
+    unsigned                    if_matched:1;
+#endif
 } ngx_http_script_engine_t;
 
 
@@ -71,6 +75,10 @@ typedef struct {
 
     union {
         size_t                  size;
+#if (NGX_HTTP_EXT)
+        ngx_msec_t              msec;
+        time_t                  sec;
+#endif
     } u;
 } ngx_http_complex_value_t;
 
@@ -186,6 +194,19 @@ typedef struct {
 } ngx_http_script_file_code_t;
 
 
+#if (NGX_HTTP_EXT)
+typedef enum {
+    ngx_http_script_if_invalid = -1,
+    ngx_http_script_if_and = 0,
+    ngx_http_script_if_or
+} ngx_http_script_if_op_e;
+
+typedef struct {
+    ngx_http_script_code_pt    code;
+    uintptr_t                  op;
+} ngx_http_script_if_operator_code_t;
+#endif
+
 typedef struct {
     ngx_http_script_code_pt     code;
     uintptr_t                   next;
@@ -213,6 +234,14 @@ ngx_int_t ngx_http_complex_value(ngx_http_request_t *r,
     ngx_http_complex_value_t *val, ngx_str_t *value);
 size_t ngx_http_complex_value_size(ngx_http_request_t *r,
     ngx_http_complex_value_t *val, size_t default_value);
+
+#if (NGX_HTTP_EXT)
+ngx_msec_t ngx_http_complex_value_msec(ngx_http_request_t *r,
+    ngx_http_complex_value_t *val, ngx_msec_t default_value);
+time_t ngx_http_complex_value_sec(ngx_http_request_t *r,
+    ngx_http_complex_value_t *val, time_t default_value);
+#endif
+
 ngx_int_t ngx_http_compile_complex_value(ngx_http_compile_complex_value_t *ccv);
 char *ngx_http_set_complex_value_slot(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
@@ -221,6 +250,12 @@ char *ngx_http_set_complex_value_zero_slot(ngx_conf_t *cf, ngx_command_t *cmd,
 char *ngx_http_set_complex_value_size_slot(ngx_conf_t *cf, ngx_command_t *cmd,
     void *conf);
 
+#if (NGX_HTTP_EXT)
+char *ngx_http_set_complex_value_msec_slot(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+char *ngx_http_set_complex_value_sec_slot(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+#endif
 
 ngx_int_t ngx_http_test_predicates(ngx_http_request_t *r,
     ngx_array_t *predicates);
@@ -255,6 +290,10 @@ void ngx_http_script_regex_end_code(ngx_http_script_engine_t *e);
 void ngx_http_script_return_code(ngx_http_script_engine_t *e);
 void ngx_http_script_break_code(ngx_http_script_engine_t *e);
 void ngx_http_script_if_code(ngx_http_script_engine_t *e);
+#if (NGX_HTTP_EXT)
+void ngx_http_script_elif_code(ngx_http_script_engine_t *e);
+void ngx_http_script_else_code(ngx_http_script_engine_t *e);
+#endif
 void ngx_http_script_equal_code(ngx_http_script_engine_t *e);
 void ngx_http_script_not_equal_code(ngx_http_script_engine_t *e);
 void ngx_http_script_file_code(ngx_http_script_engine_t *e);
@@ -265,5 +304,17 @@ void ngx_http_script_var_set_handler_code(ngx_http_script_engine_t *e);
 void ngx_http_script_var_code(ngx_http_script_engine_t *e);
 void ngx_http_script_nop_code(ngx_http_script_engine_t *e);
 
+#if (NGX_HTTP_EXT)
+void ngx_http_script_if_operator_code(ngx_http_script_engine_t *e);
+
+ngx_int_t ngx_http_script_auto_atofp(u_char *data1, size_t len1,
+    u_char *data2, size_t len2, ngx_int_t *val1, ngx_int_t *val2);
+void ngx_http_script_greater_than_code(ngx_http_script_engine_t *e);
+void ngx_http_script_greater_equal_code(ngx_http_script_engine_t *e);
+void ngx_http_script_less_than_code(ngx_http_script_engine_t *e);
+void ngx_http_script_less_equal_code(ngx_http_script_engine_t *e);
+void ngx_http_script_start_with_code(ngx_http_script_engine_t *e);
+void ngx_http_script_not_start_with_code(ngx_http_script_engine_t *e);
+#endif
 
 #endif /* _NGX_HTTP_SCRIPT_H_INCLUDED_ */
diff --git a/src/http/ngx_http_special_response.c b/src/http/ngx_http_special_response.c
index b5db811..ed2d57c 100644
--- a/src/http/ngx_http_special_response.c
+++ b/src/http/ngx_http_special_response.c
@@ -16,6 +16,9 @@ static ngx_int_t ngx_http_send_error_page(ngx_http_request_t *r,
 static ngx_int_t ngx_http_send_special_response(ngx_http_request_t *r,
     ngx_http_core_loc_conf_t *clcf, ngx_uint_t err);
 static ngx_int_t ngx_http_send_refresh(ngx_http_request_t *r);
+#if (NGX_HTTP_EXT)
+static ngx_buf_t *ngx_http_set_server_info(ngx_http_request_t *r);
+#endif
 
 
 static u_char ngx_http_error_full_tail[] =
@@ -39,6 +42,51 @@ static u_char ngx_http_error_tail[] =
 ;
 
 
+#if (NGX_HTTP_EXT)
+static u_char ngx_http_error_server_info_head[] =
+"<hr><center><p>Please report this error and include the following information</p></center>" CRLF
+"<center><table><tbody>" CRLF
+"<tr>" CRLF
+"<td>Date:</td>" CRLF
+"<td>"
+;
+
+
+static u_char ngx_http_error_server_info_ip[] =
+"</td>" CRLF
+"</tr>" CRLF
+"<tr>" CRLF
+"<td>IP:</td>" CRLF
+"<td>"
+;
+
+
+static u_char ngx_http_error_server_info_server[] =
+"</td>" CRLF
+"</tr>" CRLF
+"<tr>" CRLF
+"<td>Server:</td>" CRLF
+"<td>"
+;
+
+
+static u_char ngx_http_error_server_info_id[] =
+"</td>" CRLF
+"</tr>" CRLF
+"<tr>" CRLF
+"<td>Request ID:</td>" CRLF
+"<td>"
+;
+
+
+static u_char ngx_http_error_server_info_tail[] =
+"</td>" CRLF
+"</tr>" CRLF
+"</tbody></table></center>" CRLF
+;
+#endif
+
+
 static u_char ngx_http_msie_padding[] =
 "<!-- a padding to disable MSIE and Chrome friendly error page -->" CRLF
 "<!-- a padding to disable MSIE and Chrome friendly error page -->" CRLF
@@ -50,7 +98,11 @@ static u_char ngx_http_msie_padding[] =
 
 
 static u_char ngx_http_msie_refresh_head[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head><meta http-equiv=\"Refresh\" content=\"0; URL=";
+#else
 "<html><head><meta http-equiv=\"Refresh\" content=\"0; URL=";
+#endif
 
 
 static u_char ngx_http_msie_refresh_tail[] =
@@ -58,192 +110,360 @@ static u_char ngx_http_msie_refresh_tail[] =
 
 
 static char ngx_http_error_301_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>301 Moved Permanently</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>301 Moved Permanently</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>301 Moved Permanently</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_302_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>302 Found</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>302 Found</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>302 Found</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_303_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>303 See Other</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>303 See Other</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>303 See Other</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_307_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>307 Temporary Redirect</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>307 Temporary Redirect</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>307 Temporary Redirect</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_308_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>308 Permanent Redirect</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>308 Permanent Redirect</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>308 Permanent Redirect</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_400_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>400 Bad Request</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>400 Bad Request</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>400 Bad Request</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_401_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>401 Authorization Required</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>401 Authorization Required</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>401 Authorization Required</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_402_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>402 Payment Required</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>402 Payment Required</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>402 Payment Required</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_403_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>403 Forbidden</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>403 Forbidden</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>403 Forbidden</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_404_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>404 Not Found</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>404 Not Found</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>404 Not Found</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_405_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>405 Not Allowed</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>405 Not Allowed</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>405 Not Allowed</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_406_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>406 Not Acceptable</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>406 Not Acceptable</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>406 Not Acceptable</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_408_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>408 Request Time-out</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>408 Request Time-out</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>408 Request Time-out</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_409_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>409 Conflict</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>409 Conflict</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>409 Conflict</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_410_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>410 Gone</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>410 Gone</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>410 Gone</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_411_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>411 Length Required</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>411 Length Required</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>411 Length Required</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_412_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>412 Precondition Failed</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>412 Precondition Failed</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>412 Precondition Failed</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_413_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>413 Request Entity Too Large</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>413 Request Entity Too Large</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>413 Request Entity Too Large</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_414_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>414 Request-URI Too Large</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>414 Request-URI Too Large</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>414 Request-URI Too Large</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_415_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>415 Unsupported Media Type</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>415 Unsupported Media Type</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>415 Unsupported Media Type</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_416_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>416 Requested Range Not Satisfiable</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>416 Requested Range Not Satisfiable</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>416 Requested Range Not Satisfiable</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_421_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>421 Misdirected Request</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>421 Misdirected Request</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>421 Misdirected Request</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_429_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>429 Too Many Requests</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>429 Too Many Requests</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>429 Too Many Requests</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_494_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>400 Request Header Or Cookie Too Large</title></head>"
+#else
 "<html>" CRLF
 "<head><title>400 Request Header Or Cookie Too Large</title></head>"
+#endif
 CRLF
 "<body>" CRLF
 "<center><h1>400 Bad Request</h1></center>" CRLF
@@ -252,8 +472,15 @@ CRLF
 
 
 static char ngx_http_error_495_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>400 The SSL certificate error</title></head>"
+#else
 "<html>" CRLF
 "<head><title>400 The SSL certificate error</title></head>"
+#endif
 CRLF
 "<body>" CRLF
 "<center><h1>400 Bad Request</h1></center>" CRLF
@@ -262,8 +489,15 @@ CRLF
 
 
 static char ngx_http_error_496_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>400 No required SSL certificate was sent</title></head>"
+#else
 "<html>" CRLF
 "<head><title>400 No required SSL certificate was sent</title></head>"
+#endif
 CRLF
 "<body>" CRLF
 "<center><h1>400 Bad Request</h1></center>" CRLF
@@ -272,8 +506,15 @@ CRLF
 
 
 static char ngx_http_error_497_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>400 The plain HTTP request was sent to HTTPS port</title></head>"
+#else
 "<html>" CRLF
 "<head><title>400 The plain HTTP request was sent to HTTPS port</title></head>"
+#endif
 CRLF
 "<body>" CRLF
 "<center><h1>400 Bad Request</h1></center>" CRLF
@@ -282,56 +523,105 @@ CRLF
 
 
 static char ngx_http_error_500_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>500 Internal Server Error</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>500 Internal Server Error</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>500 Internal Server Error</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_501_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>501 Not Implemented</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>501 Not Implemented</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>501 Not Implemented</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_502_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>502 Bad Gateway</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>502 Bad Gateway</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>502 Bad Gateway</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_503_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>503 Service Temporarily Unavailable</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>503 Service Temporarily Unavailable</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>503 Service Temporarily Unavailable</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_504_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>504 Gateway Time-out</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>504 Gateway Time-out</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>504 Gateway Time-out</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_505_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>505 HTTP Version Not Supported</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>505 HTTP Version Not Supported</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>505 HTTP Version Not Supported</h1></center>" CRLF
 ;
 
 
 static char ngx_http_error_507_page[] =
+#if (NGX_HTTP_EXT)
+"<!DOCTYPE html><html><head>" CRLF
+"<meta charset=\"utf-8\">" CRLF
+"<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">" CRLF
+"<title>507 Insufficient Storage</title></head>" CRLF
+#else
 "<html>" CRLF
 "<head><title>507 Insufficient Storage</title></head>" CRLF
+#endif
 "<body>" CRLF
 "<center><h1>507 Insufficient Storage</h1></center>" CRLF
 ;
@@ -678,7 +968,14 @@ ngx_http_send_special_response(ngx_http_request_t *r,
     ngx_int_t     rc;
     ngx_buf_t    *b;
     ngx_uint_t    msie_padding;
+
+#if (NGX_HTTP_EXT)
+    ngx_chain_t   out[4];
+    ngx_buf_t    *ib;
+    ngx_uint_t    i;
+#else
     ngx_chain_t   out[3];
+#endif
 
     if (clcf->server_tokens == NGX_HTTP_SERVER_TOKENS_ON) {
         len = sizeof(ngx_http_error_full_tail) - 1;
@@ -693,10 +990,28 @@ ngx_http_send_special_response(ngx_http_request_t *r,
         tail = ngx_http_error_tail;
     }
 
+#if (NGX_HTTP_EXT)
+    if (clcf->error_page_server_info && err >= NGX_HTTP_OFF_4XX) {
+        ib = ngx_http_set_server_info(r);
+        if (ib == NULL) {
+            return NGX_ERROR;
+        }
+
+    } else {
+        ib = NULL;
+    }
+#endif
+
     msie_padding = 0;
 
     if (ngx_http_error_pages[err].len) {
+#if (NGX_HTTP_EXT)
+        r->headers_out.content_length_n = ngx_http_error_pages[err].len
+                                          + (ib ? (ib->last - ib->pos) : 0)
+                                          + len;
+#else
         r->headers_out.content_length_n = ngx_http_error_pages[err].len + len;
+#endif
         if (clcf->msie_padding
             && (r->headers_in.msie || r->headers_in.chrome)
             && r->http_version >= NGX_HTTP_VERSION_10
@@ -734,6 +1049,10 @@ ngx_http_send_special_response(ngx_http_request_t *r,
         return ngx_http_send_special(r, NGX_HTTP_LAST);
     }
 
+#if (NGX_HTTP_EXT)
+    i = 0;
+#endif
+
     b = ngx_calloc_buf(r->pool);
     if (b == NULL) {
         return NGX_ERROR;
@@ -743,8 +1062,20 @@ ngx_http_send_special_response(ngx_http_request_t *r,
     b->pos = ngx_http_error_pages[err].data;
     b->last = ngx_http_error_pages[err].data + ngx_http_error_pages[err].len;
 
+#if (NGX_HTTP_EXT)
+    out[i].buf = b;
+    out[i].next = &out[i + 1];
+    i++;
+
+    if (ib) {
+        out[i].buf = ib;
+        out[i].next = &out[i + 1];
+        i++;
+    }
+#else
     out[0].buf = b;
     out[0].next = &out[1];
+#endif
 
     b = ngx_calloc_buf(r->pool);
     if (b == NULL) {
@@ -756,8 +1087,13 @@ ngx_http_send_special_response(ngx_http_request_t *r,
     b->pos = tail;
     b->last = tail + len;
 
+#if (NGX_HTTP_EXT)
+    out[i].buf = b;
+    out[i].next = NULL;
+#else
     out[1].buf = b;
     out[1].next = NULL;
+#endif
 
     if (msie_padding) {
         b = ngx_calloc_buf(r->pool);
@@ -769,9 +1105,16 @@ ngx_http_send_special_response(ngx_http_request_t *r,
         b->pos = ngx_http_msie_padding;
         b->last = ngx_http_msie_padding + sizeof(ngx_http_msie_padding) - 1;
 
+#if (NGX_HTTP_EXT)
+        out[i].next = &out[i + 1];
+        i++;
+        out[i].buf = b;
+        out[i].next = NULL;
+#else
         out[1].next = &out[2];
         out[2].buf = b;
         out[2].next = NULL;
+#endif
     }
 
     if (r == r->main) {
@@ -855,3 +1198,71 @@ ngx_http_send_refresh(ngx_http_request_t *r)
 
     return ngx_http_output_filter(r, &out);
 }
+
+
+#if (NGX_HTTP_EXT)
+static ngx_buf_t *
+ngx_http_set_server_info(ngx_http_request_t *r)
+{
+    size_t                     size;
+    ngx_buf_t                 *b;
+    ngx_str_t                  client_ip, request_id;
+    ngx_http_core_loc_conf_t  *clcf;
+
+    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
+
+    if (!clcf->error_page_client_ip ||
+        ngx_http_complex_value(r, clcf->error_page_client_ip, &client_ip)
+        != NGX_OK) {
+        client_ip.data = (u_char *)"-";
+        client_ip.len = 1;
+    }
+
+    if (!clcf->error_page_client_ip ||
+        ngx_http_complex_value(r, clcf->error_page_request_id, &request_id)
+        != NGX_OK) {
+        request_id.data = (u_char *)"-";
+        request_id.len = 1;
+    }
+
+    size = sizeof(ngx_http_error_server_info_head) - 1
+           + ngx_cached_http_time.len
+           + sizeof(ngx_http_error_server_info_ip) - 1
+           + client_ip.len
+           + sizeof(ngx_http_error_server_info_server) - 1
+           + ngx_cycle->hostname.len
+           + sizeof(ngx_http_error_server_info_id) - 1
+           + request_id.len
+           + sizeof(ngx_http_error_server_info_tail) - 1;
+
+    b = ngx_create_temp_buf(r->pool, size);
+    if (b == NULL) {
+        return NULL;
+    }
+
+    b->last = ngx_cpymem(b->last, ngx_http_error_server_info_head,
+                         sizeof(ngx_http_error_server_info_head) - 1);
+    b->last = ngx_cpymem(b->last, ngx_cached_http_time.data,
+                         ngx_cached_http_time.len);
+
+    b->last = ngx_cpymem(b->last, ngx_http_error_server_info_ip,
+                         sizeof(ngx_http_error_server_info_ip) - 1);
+    b->last = ngx_cpymem(b->last, client_ip.data,
+                         client_ip.len);
+
+    b->last = ngx_cpymem(b->last, ngx_http_error_server_info_server,
+                         sizeof(ngx_http_error_server_info_server) - 1);
+    b->last = ngx_cpymem(b->last, ngx_cycle->hostname.data,
+                         ngx_cycle->hostname.len);
+
+    b->last = ngx_cpymem(b->last, ngx_http_error_server_info_id,
+                         sizeof(ngx_http_error_server_info_id) - 1);
+    b->last = ngx_cpymem(b->last, request_id.data,
+                         request_id.len);
+
+    b->last = ngx_cpymem(b->last, ngx_http_error_server_info_tail,
+                         sizeof(ngx_http_error_server_info_tail) - 1);
+
+    return b;
+}
+#endif
\ No newline at end of file
diff --git a/src/http/ngx_http_upstream.c b/src/http/ngx_http_upstream.c
index d04d91e..68b8ad5 100644
--- a/src/http/ngx_http_upstream.c
+++ b/src/http/ngx_http_upstream.c
@@ -21,6 +21,12 @@ static ngx_int_t ngx_http_upstream_cache_background_update(
     ngx_http_request_t *r, ngx_http_upstream_t *u);
 static ngx_int_t ngx_http_upstream_cache_check_range(ngx_http_request_t *r,
     ngx_http_upstream_t *u);
+
+#if (NGX_HTTP_EXT)
+static ngx_int_t ngx_http_upstream_cache_test_content_type(
+    ngx_http_request_t *r, ngx_http_upstream_t *u);
+#endif
+
 static ngx_int_t ngx_http_upstream_cache_status(ngx_http_request_t *r,
     ngx_http_variable_value_t *v, uintptr_t data);
 static ngx_int_t ngx_http_upstream_cache_last_modified(ngx_http_request_t *r,
@@ -117,6 +123,10 @@ static ngx_int_t ngx_http_upstream_ignore_header_line(ngx_http_request_t *r,
     ngx_table_elt_t *h, ngx_uint_t offset);
 static ngx_int_t ngx_http_upstream_process_expires(ngx_http_request_t *r,
     ngx_table_elt_t *h, ngx_uint_t offset);
+#if (NGX_HTTP_EXT)
+static ngx_int_t ngx_http_upstream_process_pragma(ngx_http_request_t *r,
+    ngx_table_elt_t *h, ngx_uint_t offset);
+#endif
 static ngx_int_t ngx_http_upstream_process_accel_expires(ngx_http_request_t *r,
     ngx_table_elt_t *h, ngx_uint_t offset);
 static ngx_int_t ngx_http_upstream_process_limit_rate(ngx_http_request_t *r,
@@ -262,6 +272,12 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {
                  ngx_http_upstream_copy_header_line,
                  offsetof(ngx_http_headers_out_t, expires), 1 },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("Pragma"),
+                 ngx_http_upstream_process_pragma, 0,
+                 ngx_http_upstream_copy_header_line, 0, 0 },
+#endif
+
     { ngx_string("Accept-Ranges"),
                  ngx_http_upstream_ignore_header_line, 0,
                  ngx_http_upstream_copy_allow_ranges,
@@ -465,11 +481,26 @@ ngx_conf_bitmask_t  ngx_http_upstream_ignore_headers_masks[] = {
     { ngx_string("X-Accel-Charset"), NGX_HTTP_UPSTREAM_IGN_XA_CHARSET },
     { ngx_string("Expires"), NGX_HTTP_UPSTREAM_IGN_EXPIRES },
     { ngx_string("Cache-Control"), NGX_HTTP_UPSTREAM_IGN_CACHE_CONTROL },
+#if (NGX_HTTP_EXT)
+    { ngx_string("Pragma"), NGX_HTTP_UPSTREAM_IGN_PRAGMA },
+#endif
     { ngx_string("Set-Cookie"), NGX_HTTP_UPSTREAM_IGN_SET_COOKIE },
     { ngx_string("Vary"), NGX_HTTP_UPSTREAM_IGN_VARY },
     { ngx_null_string, 0 }
 };
 
+#if (NGX_HTTP_EXT)
+ngx_conf_bitmask_t  ngx_http_upstream_ignore_cache_control_masks[] = {
+    { ngx_string("no-cache"), NGX_HTTP_UPSTREAM_IGN_CC_NOCACHE },
+    { ngx_string("no-store"), NGX_HTTP_UPSTREAM_IGN_CC_NOSTORE },
+    { ngx_string("private"), NGX_HTTP_UPSTREAM_IGN_CC_PRIVATE },
+    { ngx_string("max-age"), NGX_HTTP_UPSTREAM_IGN_CC_MAXAGE },
+    { ngx_string("s-maxage"), NGX_HTTP_UPSTREAM_IGN_CC_SMAXAGE },
+    { ngx_string("stale-while-revalidate"), NGX_HTTP_UPSTREAM_IGN_CC_STALE_WR },
+    { ngx_string("stale-if-error"), NGX_HTTP_UPSTREAM_IGN_CC_STALE_IE },
+    { ngx_null_string, 0 }
+};
+#endif
 
 ngx_int_t
 ngx_http_upstream_create(ngx_http_request_t *r)
@@ -1193,6 +1224,21 @@ ngx_http_upstream_cache_check_range(ngx_http_request_t *r,
     return NGX_OK;
 }
 
+#if (NGX_HTTP_EXT)
+static ngx_int_t ngx_http_upstream_cache_test_content_type(
+    ngx_http_request_t *r, ngx_http_upstream_t *u)
+{
+    if (ngx_http_test_content_type(r, &u->conf->cache_types) == NULL) {
+        ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+            "http upstream cache: not match content types, skip caching");
+
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+#endif
+
 #endif
 
 
@@ -1555,6 +1601,17 @@ ngx_http_upstream_connect(ngx_http_request_t *r, ngx_http_upstream_t *u)
 
     u->start_time = ngx_current_msec;
 
+#if (NGX_HTTP_EXT)
+    u->state->start_msec = ngx_current_msec;
+
+#if (NGX_HTTP_SSL)
+    u->state->ssl_start_msec = (ngx_msec_t) -1;
+#endif
+
+    u->state->send_start_msec = (ngx_msec_t) -1;
+    u->state->send_end_msec = (ngx_msec_t) -1;
+#endif
+
     u->state->response_time = (ngx_msec_t) -1;
     u->state->connect_time = (ngx_msec_t) -1;
     u->state->header_time = (ngx_msec_t) -1;
@@ -1754,6 +1811,12 @@ ngx_http_upstream_ssl_init_connection(ngx_http_request_t *r,
         }
     }
 
+#if (NGX_HTTP_EXT)
+    if (u->state && u->state->ssl_start_msec == (ngx_msec_t) -1) {
+        u->state->ssl_start_msec = ngx_current_msec;
+    }
+#endif
+
     r->connection->log->action = "SSL handshaking to upstream";
 
     rc = ngx_ssl_handshake(c);
@@ -2108,6 +2171,12 @@ ngx_http_upstream_send_request(ngx_http_request_t *r, ngx_http_upstream_t *u,
         return;
     }
 
+#if (NGX_HTTP_EXT)
+    if (u->state->send_start_msec == (ngx_msec_t) -1) {
+        u->state->send_start_msec = ngx_current_msec;
+    }
+#endif
+
     c->log->action = "sending request to upstream";
 
     rc = ngx_http_upstream_send_request_body(r, u, do_write);
@@ -2161,6 +2230,10 @@ ngx_http_upstream_send_request(ngx_http_request_t *r, ngx_http_upstream_t *u,
         ngx_del_timer(c->write);
     }
 
+#if (NGX_HTTP_EXT)
+    u->state->send_end_msec = ngx_current_msec;
+#endif
+
     if (c->tcp_nopush == NGX_TCP_NOPUSH_SET) {
         if (ngx_tcp_push(c->fd) == -1) {
             ngx_log_error(NGX_LOG_CRIT, c->log, ngx_socket_errno,
@@ -2648,8 +2721,13 @@ ngx_http_upstream_test_next(ngx_http_request_t *r, ngx_http_upstream_t *u)
         }
 
         if (valid == 0) {
+#if (NGX_HTTP_EXT)
+            valid = ngx_http_file_cache_valid(r, u->conf->cache_valid,
+                                              u->headers_in.status_n);
+#else
             valid = ngx_http_file_cache_valid(u->conf->cache_valid,
                                               u->headers_in.status_n);
+#endif
             if (valid) {
                 valid = now + valid;
             }
@@ -2746,8 +2824,13 @@ ngx_http_upstream_intercept_errors(ngx_http_request_t *r,
                     valid = r->cache->valid_sec;
 
                     if (valid == 0) {
+#if (NGX_HTTP_EXT)
+                        valid = ngx_http_file_cache_valid(r, u->conf->cache_valid,
+                                                          status);
+#else
                         valid = ngx_http_file_cache_valid(u->conf->cache_valid,
                                                           status);
+#endif
                         if (valid) {
                             r->cache->valid_sec = ngx_time() + valid;
                         }
@@ -3164,6 +3247,12 @@ ngx_http_upstream_send_response(ngx_http_request_t *r, ngx_http_upstream_t *u)
 
     default: /* NGX_OK */
 
+#if (NGX_HTTP_EXT)
+        if (ngx_http_upstream_cache_test_content_type(r, u) != NGX_OK) {
+            u->cacheable = 0;
+            break;
+        }
+#endif
         if (u->cache_status == NGX_HTTP_CACHE_BYPASS) {
 
             /* create cache if previously bypassed */
@@ -3185,8 +3274,13 @@ ngx_http_upstream_send_response(ngx_http_request_t *r, ngx_http_upstream_t *u)
         valid = r->cache->valid_sec;
 
         if (valid == 0) {
+#if (NGX_HTTP_EXT)
+            valid = ngx_http_file_cache_valid(r, u->conf->cache_valid,
+                                              u->headers_in.status_n);
+#else
             valid = ngx_http_file_cache_valid(u->conf->cache_valid,
                                               u->headers_in.status_n);
+#endif
             if (valid) {
                 r->cache->valid_sec = now + valid;
             }
@@ -4617,7 +4711,11 @@ ngx_http_upstream_finalize_request(ngx_http_request_t *r,
             if (rc == NGX_HTTP_BAD_GATEWAY || rc == NGX_HTTP_GATEWAY_TIME_OUT) {
                 time_t  valid;
 
+#if (NGX_HTTP_EXT)
+                valid = ngx_http_file_cache_valid(r, u->conf->cache_valid, rc);
+#else
                 valid = ngx_http_file_cache_valid(u->conf->cache_valid, rc);
+#endif
 
                 if (valid) {
                     r->cache->valid_sec = ngx_time() + valid;
@@ -4857,6 +4955,18 @@ ngx_http_upstream_process_cache_control(ngx_http_request_t *r,
         goto extensions;
     }
 
+#if (NGX_HTTP_EXT)
+    if ((ngx_strlcasestrn(start, last, (u_char *) "no-cache", 8 - 1) != NULL 
+            && !(u->conf->ignore_cache_control & NGX_HTTP_UPSTREAM_IGN_CC_NOCACHE))
+        || (ngx_strlcasestrn(start, last, (u_char *) "no-store", 8 - 1) != NULL
+            && !(u->conf->ignore_cache_control & NGX_HTTP_UPSTREAM_IGN_CC_NOSTORE))
+        || (ngx_strlcasestrn(start, last, (u_char *) "private", 7 - 1) != NULL
+            && !(u->conf->ignore_cache_control & NGX_HTTP_UPSTREAM_IGN_CC_PRIVATE)))
+    {
+        u->headers_in.no_cache = 1;
+        return NGX_OK;
+    }
+#else
     if (ngx_strlcasestrn(start, last, (u_char *) "no-cache", 8 - 1) != NULL
         || ngx_strlcasestrn(start, last, (u_char *) "no-store", 8 - 1) != NULL
         || ngx_strlcasestrn(start, last, (u_char *) "private", 7 - 1) != NULL)
@@ -4864,14 +4974,30 @@ ngx_http_upstream_process_cache_control(ngx_http_request_t *r,
         u->headers_in.no_cache = 1;
         return NGX_OK;
     }
+#endif
 
     p = ngx_strlcasestrn(start, last, (u_char *) "s-maxage=", 9 - 1);
+#if (NGX_HTTP_EXT)
+    if (p && !(u->conf->ignore_cache_control & NGX_HTTP_UPSTREAM_IGN_CC_SMAXAGE))
+    {
+        offset = 9;
+    }
+    else if ((p = ngx_strlcasestrn(start, last, (u_char *) "max-age=", 7))
+        && !(u->conf->ignore_cache_control & NGX_HTTP_UPSTREAM_IGN_CC_MAXAGE))
+    {
+        offset = 8;
+    }
+    else {
+        p = NULL;
+    }
+#else
     offset = 9;
 
     if (p == NULL) {
         p = ngx_strlcasestrn(start, last, (u_char *) "max-age=", 8 - 1);
         offset = 8;
     }
+#endif
 
     if (p) {
         n = 0;
@@ -4895,7 +5021,17 @@ ngx_http_upstream_process_cache_control(ngx_http_request_t *r,
             return NGX_OK;
         }
 
+#if (NGX_HTTP_EXT)
+        time_t min_age = ngx_http_complex_value_sec(r, u->conf->cache_min_age, 0);
+        if (min_age > n) {
+            r->cache->valid_sec = ngx_time() + min_age;
+        } else {
+            r->cache->valid_sec = ngx_time() + n;
+        }
+#else
         r->cache->valid_sec = ngx_time() + n;
+#endif
+
         u->headers_in.expired = 0;
     }
 
@@ -4904,7 +5040,12 @@ extensions:
     p = ngx_strlcasestrn(start, last, (u_char *) "stale-while-revalidate=",
                          23 - 1);
 
+#if (NGX_HTTP_EXT)
+    if (p && !(u->conf->ignore_cache_control
+               & NGX_HTTP_UPSTREAM_IGN_CC_STALE_WR)) {
+#else
     if (p) {
+#endif
         n = 0;
 
         for (p += 23; p < last; p++) {
@@ -4923,11 +5064,27 @@ extensions:
 
         r->cache->updating_sec = n;
         r->cache->error_sec = n;
+#if (NGX_HTTP_EXT)
+    } else {
+
+        time_t max_stale_while_revalidate = ngx_http_complex_value_sec(r,
+            u->conf->cache_stale_while_revalidate, 0);
+
+        if (max_stale_while_revalidate > 0) {
+            r->cache->updating_sec = max_stale_while_revalidate;
+            r->cache->error_sec = max_stale_while_revalidate;
+        }
+#endif
     }
 
     p = ngx_strlcasestrn(start, last, (u_char *) "stale-if-error=", 15 - 1);
 
+#if (NGX_HTTP_EXT)
+    if (p && !(u->conf->ignore_cache_control
+               & NGX_HTTP_UPSTREAM_IGN_CC_STALE_IE)) {
+#else
     if (p) {
+#endif
         n = 0;
 
         for (p += 15; p < last; p++) {
@@ -4945,6 +5102,16 @@ extensions:
         }
 
         r->cache->error_sec = n;
+#if (NGX_HTTP_EXT)
+    } else {
+
+        time_t max_stale_if_error = ngx_http_complex_value_sec(r,
+            u->conf->cache_stale_if_error, 0);
+
+        if (max_stale_if_error > 0) {
+            r->cache->error_sec = max_stale_if_error;
+        }
+#endif
     }
     }
 #endif
@@ -5006,6 +5173,56 @@ ngx_http_upstream_process_expires(ngx_http_request_t *r, ngx_table_elt_t *h,
 }
 
 
+#if (NGX_HTTP_EXT)
+static ngx_int_t
+ngx_http_upstream_process_pragma(ngx_http_request_t *r,
+    ngx_table_elt_t *h, ngx_uint_t offset)
+{
+    ngx_http_upstream_t  *u;
+
+    u = r->upstream;
+
+    if (u->headers_in.pragma) {
+        ngx_log_error(NGX_LOG_WARN, r->connection->log, 0,
+                      "upstream sent duplicate header line: \"%V: %V\", "
+                      "previous value: \"%V: %V\", ignored",
+                      &h->key, &h->value,
+                      &u->headers_in.pragma->key,
+                      &u->headers_in.pragma->value);
+        h->hash = 0;
+        return NGX_OK;
+    }
+
+    u->headers_in.pragma = h;
+    h->next = NULL;
+
+#if (NGX_HTTP_CACHE)
+    {
+    if (u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_PRAGMA) {
+        return NGX_OK;
+    }
+
+    if (r->cache == NULL) {
+        return NGX_OK;
+    }
+
+    if (r->cache->valid_sec != 0 && u->headers_in.x_accel_expires != NULL) {
+        return NGX_OK;
+    }
+
+    if (ngx_strlcasestrn(h->value.data, h->value.data + h->value.len,
+        (u_char *) "no-cache", 8 - 1) != NULL) {
+        u->headers_in.no_cache = 1;
+        return NGX_OK;
+    }
+    }
+#endif
+
+    return NGX_OK;
+}
+#endif
+
+
 static ngx_int_t
 ngx_http_upstream_process_accel_expires(ngx_http_request_t *r,
     ngx_table_elt_t *h, ngx_uint_t offset)
diff --git a/src/http/ngx_http_upstream.h b/src/http/ngx_http_upstream.h
index f6621af..822783b 100644
--- a/src/http/ngx_http_upstream.h
+++ b/src/http/ngx_http_upstream.h
@@ -54,6 +54,18 @@
 #define NGX_HTTP_UPSTREAM_IGN_XA_BUFFERING   0x00000080
 #define NGX_HTTP_UPSTREAM_IGN_XA_CHARSET     0x00000100
 #define NGX_HTTP_UPSTREAM_IGN_VARY           0x00000200
+#if (NGX_HTTP_EXT)
+#define NGX_HTTP_UPSTREAM_IGN_PRAGMA         0x00000400
+
+
+#define NGX_HTTP_UPSTREAM_IGN_CC_NOCACHE     0x00000002
+#define NGX_HTTP_UPSTREAM_IGN_CC_NOSTORE     0x00000004
+#define NGX_HTTP_UPSTREAM_IGN_CC_PRIVATE     0x00000008
+#define NGX_HTTP_UPSTREAM_IGN_CC_MAXAGE      0x00000010
+#define NGX_HTTP_UPSTREAM_IGN_CC_SMAXAGE     0x00000020
+#define NGX_HTTP_UPSTREAM_IGN_CC_STALE_WR    0x00000040
+#define NGX_HTTP_UPSTREAM_IGN_CC_STALE_IE    0x00000080
+#endif
 
 
 typedef struct {
@@ -62,6 +74,18 @@ typedef struct {
     ngx_msec_t                       connect_time;
     ngx_msec_t                       header_time;
     ngx_msec_t                       queue_time;
+
+#if (NGX_HTTP_EXT)
+    ngx_msec_t                       start_msec;
+
+#if (NGX_HTTP_SSL)
+    ngx_msec_t                       ssl_start_msec;
+#endif
+
+    ngx_msec_t                       send_start_msec;
+    ngx_msec_t                       send_end_msec;
+#endif
+
     off_t                            response_length;
     off_t                            bytes_received;
     off_t                            bytes_sent;
@@ -169,6 +193,9 @@ typedef struct {
     ngx_bufs_t                       bufs;
 
     ngx_uint_t                       ignore_headers;
+#if (NGX_HTTP_EXT)
+    ngx_uint_t                       ignore_cache_control;
+#endif
     ngx_uint_t                       next_upstream;
     ngx_uint_t                       store_access;
     ngx_uint_t                       next_upstream_tries;
@@ -195,8 +222,15 @@ typedef struct {
     ngx_shm_zone_t                  *cache_zone;
     ngx_http_complex_value_t        *cache_value;
 
+#if (NGX_HTTP_EXT)
+    ngx_http_complex_value_t        *cache_min_age;
+#endif
     ngx_uint_t                       cache_min_uses;
     ngx_uint_t                       cache_use_stale;
+#if (NGX_HTTP_EXT)
+    ngx_http_complex_value_t        *cache_stale_if_error;
+    ngx_http_complex_value_t        *cache_stale_while_revalidate;
+#endif
     ngx_uint_t                       cache_methods;
 
     off_t                            cache_max_range_offset;
@@ -213,6 +247,11 @@ typedef struct {
     ngx_array_t                     *cache_bypass;
     ngx_array_t                     *cache_purge;
     ngx_array_t                     *no_cache;
+#if (NGX_HTTP_EXT)
+    ngx_array_t                     *cache_types_keys;
+
+    ngx_hash_t                       cache_types;
+#endif
 #endif
 
     ngx_array_t                     *store_lengths;
@@ -286,6 +325,9 @@ typedef struct {
     ngx_table_elt_t                 *vary;
 
     ngx_table_elt_t                 *cache_control;
+#if (NGX_HTTP_EXT)
+    ngx_table_elt_t                 *pragma;
+#endif
     ngx_table_elt_t                 *set_cookie;
 
     off_t                            content_length_n;
@@ -381,6 +423,10 @@ struct ngx_http_upstream_s {
     ngx_str_t                        schema;
     ngx_str_t                        uri;
 
+#if (NGX_HTTP_EXT)
+    ngx_str_t                        method_name;
+#endif
+
 #if (NGX_HTTP_SSL || NGX_COMPAT)
     ngx_str_t                        ssl_name;
 #endif
@@ -442,6 +488,9 @@ ngx_int_t ngx_http_upstream_hide_headers_hash(ngx_conf_t *cf,
 extern ngx_module_t        ngx_http_upstream_module;
 extern ngx_conf_bitmask_t  ngx_http_upstream_cache_method_mask[];
 extern ngx_conf_bitmask_t  ngx_http_upstream_ignore_headers_masks[];
+#if (NGX_HTTP_EXT)
+extern ngx_conf_bitmask_t  ngx_http_upstream_ignore_cache_control_masks[];
+#endif
 
 
 #ifndef HAVE_BALANCER_STATUS_CODE_PATCH
diff --git a/src/http/v2/ngx_http_v2_filter_module.c b/src/http/v2/ngx_http_v2_filter_module.c
index 2024395..81e409b 100644
--- a/src/http/v2/ngx_http_v2_filter_module.c
+++ b/src/http/v2/ngx_http_v2_filter_module.c
@@ -113,6 +113,9 @@ ngx_http_v2_header_filter(ngx_http_request_t *r)
     ngx_http_v2_connection_t  *h2c;
     ngx_http_core_loc_conf_t  *clcf;
     ngx_http_core_srv_conf_t  *cscf;
+#if (NGX_HTTP_EXT)
+    ngx_time_t                *tp;
+#endif
     u_char                     addr[NGX_SOCKADDR_STRLEN];
 
     static const u_char nginx[8] = "\x87\x3d\x65\xaa\xc2\xa1\x3e\xbf";
@@ -143,6 +146,12 @@ ngx_http_v2_header_filter(ngx_http_request_t *r)
 
     r->header_sent = 1;
 
+#if (NGX_HTTP_EXT)
+    tp = ngx_timeofday();
+    r->header_sent_sec = tp->sec;
+    r->header_sent_msec = tp->msec;
+#endif
+
     if (r != r->main) {
         return NGX_OK;
     }
diff --git a/src/http/v3/ngx_http_v3_filter_module.c b/src/http/v3/ngx_http_v3_filter_module.c
index 4d2276d..6dab2f9 100644
--- a/src/http/v3/ngx_http_v3_filter_module.c
+++ b/src/http/v3/ngx_http_v3_filter_module.c
@@ -94,6 +94,9 @@ ngx_http_v3_header_filter(ngx_http_request_t *r)
     ngx_http_v3_filter_ctx_t  *ctx;
     ngx_http_core_loc_conf_t  *clcf;
     ngx_http_core_srv_conf_t  *cscf;
+#if (NGX_HTTP_EXT)
+    ngx_time_t                *tp;
+#endif
     u_char                     addr[NGX_SOCKADDR_STRLEN];
 
     if (r->http_version != NGX_HTTP_VERSION_30) {
@@ -106,6 +109,12 @@ ngx_http_v3_header_filter(ngx_http_request_t *r)
 
     r->header_sent = 1;
 
+#if (NGX_HTTP_EXT)
+    tp = ngx_timeofday();
+    r->header_sent_sec = tp->sec;
+    r->header_sent_msec = tp->msec;
+#endif
+
     if (r != r->main) {
         return NGX_OK;
     }
diff --git a/src/stream/ngx_stream_ssl_module.c b/src/stream/ngx_stream_ssl_module.c
index ba44477..8cd5da8 100644
--- a/src/stream/ngx_stream_ssl_module.c
+++ b/src/stream/ngx_stream_ssl_module.c
@@ -329,6 +329,17 @@ static ngx_stream_variable_t  ngx_stream_ssl_vars[] = {
     { ngx_string("ssl_client_v_remain"), NULL, ngx_stream_ssl_variable,
       (uintptr_t) ngx_ssl_get_client_v_remain, NGX_STREAM_VAR_CHANGEABLE, 0 },
 
+#if (NGX_HTTP_EXT)
+    { ngx_string("ssl_handshake_time"), NULL, ngx_stream_ssl_variable,
+      (uintptr_t) ngx_ssl_get_handshake_time, NGX_STREAM_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_handshake_start_ts"), NULL, ngx_stream_ssl_variable,
+      (uintptr_t) ngx_ssl_get_handshake_start_ts, NGX_STREAM_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_handshake_end_ts"), NULL, ngx_stream_ssl_variable,
+      (uintptr_t) ngx_ssl_get_handshake_end_ts, NGX_STREAM_VAR_CHANGEABLE, 0 },
+#endif
+
       ngx_stream_null_variable
 };
 
@@ -406,6 +417,10 @@ ngx_stream_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c)
     ngx_stream_ssl_srv_conf_t   *sscf;
     ngx_stream_core_srv_conf_t  *cscf;
 
+#if (NGX_HTTP_EXT)
+    ngx_time_t                  *tp;
+#endif
+
     s = c->data;
 
     cscf = ngx_stream_get_module_srv_conf(s, ngx_stream_core_module);
@@ -418,6 +433,11 @@ ngx_stream_ssl_init_connection(ngx_ssl_t *ssl, ngx_connection_t *c)
         return NGX_ERROR;
     }
 
+#if (NGX_HTTP_EXT)
+    tp = ngx_timeofday();
+    c->ssl->handshake_start_msec = tp->sec * 1000 + tp->msec;
+#endif
+
     rc = ngx_ssl_handshake(c);
 
     if (rc == NGX_ERROR) {
